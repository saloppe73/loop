// Code generated by protoc-gen-go. DO NOT EDIT.
// source: client.proto

package looprpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SwapType int32

const (
	// LOOP_OUT indicates an loop out swap (off-chain to on-chain)
	SwapType_LOOP_OUT SwapType = 0
	// LOOP_IN indicates a loop in swap (on-chain to off-chain)
	SwapType_LOOP_IN SwapType = 1
)

var SwapType_name = map[int32]string{
	0: "LOOP_OUT",
	1: "LOOP_IN",
}

var SwapType_value = map[string]int32{
	"LOOP_OUT": 0,
	"LOOP_IN":  1,
}

func (x SwapType) String() string {
	return proto.EnumName(SwapType_name, int32(x))
}

func (SwapType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{0}
}

type SwapState int32

const (
	//
	//INITIATED is the initial state of a swap. At that point, the initiation
	//call to the server has been made and the payment process has been started
	//for the swap and prepayment invoices.
	SwapState_INITIATED SwapState = 0
	//
	//PREIMAGE_REVEALED is reached when the sweep tx publication is first
	//attempted. From that point on, we should consider the preimage to no
	//longer be secret and we need to do all we can to get the sweep confirmed.
	//This state will mostly coalesce with StateHtlcConfirmed, except in the
	//case where we wait for fees to come down before we sweep.
	SwapState_PREIMAGE_REVEALED SwapState = 1
	//
	//HTLC_PUBLISHED is reached when the htlc tx has been published in a loop in
	//swap.
	SwapState_HTLC_PUBLISHED SwapState = 2
	//
	//SUCCESS is the final swap state that is reached when the sweep tx has
	//the required confirmation depth.
	SwapState_SUCCESS SwapState = 3
	//
	//FAILED is the final swap state for a failed swap with or without loss of
	//the swap amount.
	SwapState_FAILED SwapState = 4
	//
	//INVOICE_SETTLED is reached when the swap invoice in a loop in swap has been
	//paid, but we are still waiting for the htlc spend to confirm.
	SwapState_INVOICE_SETTLED SwapState = 5
)

var SwapState_name = map[int32]string{
	0: "INITIATED",
	1: "PREIMAGE_REVEALED",
	2: "HTLC_PUBLISHED",
	3: "SUCCESS",
	4: "FAILED",
	5: "INVOICE_SETTLED",
}

var SwapState_value = map[string]int32{
	"INITIATED":         0,
	"PREIMAGE_REVEALED": 1,
	"HTLC_PUBLISHED":    2,
	"SUCCESS":           3,
	"FAILED":            4,
	"INVOICE_SETTLED":   5,
}

func (x SwapState) String() string {
	return proto.EnumName(SwapState_name, int32(x))
}

func (SwapState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{1}
}

type FailureReason int32

const (
	//
	//FAILURE_REASON_NONE is set when the swap did not fail, it is either in
	//progress or succeeded.
	FailureReason_FAILURE_REASON_NONE FailureReason = 0
	//
	//FAILURE_REASON_OFFCHAIN indicates that a loop out failed because it wasn't
	//possible to find a route for one or both off chain payments that met the fee
	//and timelock limits required.
	FailureReason_FAILURE_REASON_OFFCHAIN FailureReason = 1
	//
	//FAILURE_REASON_TIMEOUT indicates that the swap failed because on chain htlc
	//did not confirm before its expiry, or it confirmed too late for us to reveal
	//our preimage and claim.
	FailureReason_FAILURE_REASON_TIMEOUT FailureReason = 2
	//
	//FAILURE_REASON_SWEEP_TIMEOUT indicates that a loop out permanently failed
	//because the on chain htlc wasn't swept before the server revoked the
	//htlc.
	FailureReason_FAILURE_REASON_SWEEP_TIMEOUT FailureReason = 3
	//
	//FAILURE_REASON_INSUFFICIENT_VALUE indicates that a loop out has failed
	//because the on chain htlc had a lower value than requested.
	FailureReason_FAILURE_REASON_INSUFFICIENT_VALUE FailureReason = 4
	//
	//FAILURE_REASON_TEMPORARY indicates that a swap cannot continue due to an
	//internal error. Manual intervention such as a restart is required.
	FailureReason_FAILURE_REASON_TEMPORARY FailureReason = 5
	//
	//FAILURE_REASON_INCORRECT_AMOUNT indicates that a loop in permanently failed
	//because the amount extended by an external loop in htlc is insufficient.
	FailureReason_FAILURE_REASON_INCORRECT_AMOUNT FailureReason = 6
)

var FailureReason_name = map[int32]string{
	0: "FAILURE_REASON_NONE",
	1: "FAILURE_REASON_OFFCHAIN",
	2: "FAILURE_REASON_TIMEOUT",
	3: "FAILURE_REASON_SWEEP_TIMEOUT",
	4: "FAILURE_REASON_INSUFFICIENT_VALUE",
	5: "FAILURE_REASON_TEMPORARY",
	6: "FAILURE_REASON_INCORRECT_AMOUNT",
}

var FailureReason_value = map[string]int32{
	"FAILURE_REASON_NONE":               0,
	"FAILURE_REASON_OFFCHAIN":           1,
	"FAILURE_REASON_TIMEOUT":            2,
	"FAILURE_REASON_SWEEP_TIMEOUT":      3,
	"FAILURE_REASON_INSUFFICIENT_VALUE": 4,
	"FAILURE_REASON_TEMPORARY":          5,
	"FAILURE_REASON_INCORRECT_AMOUNT":   6,
}

func (x FailureReason) String() string {
	return proto.EnumName(FailureReason_name, int32(x))
}

func (FailureReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{2}
}

type LiquidityRuleType int32

const (
	LiquidityRuleType_UNKNOWN   LiquidityRuleType = 0
	LiquidityRuleType_THRESHOLD LiquidityRuleType = 1
)

var LiquidityRuleType_name = map[int32]string{
	0: "UNKNOWN",
	1: "THRESHOLD",
}

var LiquidityRuleType_value = map[string]int32{
	"UNKNOWN":   0,
	"THRESHOLD": 1,
}

func (x LiquidityRuleType) String() string {
	return proto.EnumName(LiquidityRuleType_name, int32(x))
}

func (LiquidityRuleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{3}
}

type AutoReason int32

const (
	AutoReason_AUTO_REASON_UNKNOWN AutoReason = 0
	//
	//Budget not started indicates that we do not recommend any swaps because
	//the start time for our budget has not arrived yet.
	AutoReason_AUTO_REASON_BUDGET_NOT_STARTED AutoReason = 1
	//
	//Sweep fees indicates that the estimated fees to sweep swaps are too high
	//right now.
	AutoReason_AUTO_REASON_SWEEP_FEES AutoReason = 2
	//
	//Budget elapsed indicates that the autoloop budget for the period has been
	//elapsed.
	AutoReason_AUTO_REASON_BUDGET_ELAPSED AutoReason = 3
	//
	//In flight indicates that the limit on in-flight automatically dispatched
	//swaps has already been reached.
	AutoReason_AUTO_REASON_IN_FLIGHT AutoReason = 4
	//
	//Swap fee indicates that the server fee for a specific swap is too high.
	AutoReason_AUTO_REASON_SWAP_FEE AutoReason = 5
	//
	//Miner fee indicates that the miner fee for a specific swap is to high.
	AutoReason_AUTO_REASON_MINER_FEE AutoReason = 6
	//
	//Prepay indicates that the prepay fee for a specific swap is too high.
	AutoReason_AUTO_REASON_PREPAY AutoReason = 7
	//
	//Failure backoff indicates that a swap has recently failed for this target,
	//and the backoff period has not yet passed.
	AutoReason_AUTO_REASON_FAILURE_BACKOFF AutoReason = 8
	//
	//Loop out indicates that a loop out swap is currently utilizing the channel,
	//so it is not eligible.
	AutoReason_AUTO_REASON_LOOP_OUT AutoReason = 9
	//
	//Loop In indicates that a loop in swap is currently in flight for the peer,
	//so it is not eligible.
	AutoReason_AUTO_REASON_LOOP_IN AutoReason = 10
	//
	//Liquidity ok indicates that a target meets the liquidity balance expressed
	//in its rule, so no swap is needed.
	AutoReason_AUTO_REASON_LIQUIDITY_OK AutoReason = 11
	//
	//Budget insufficient indicates that we cannot perform a swap because we do
	//not have enough pending budget available. This differs from budget elapsed,
	//because we still have some budget available, but we have allocated it to
	//other swaps.
	AutoReason_AUTO_REASON_BUDGET_INSUFFICIENT AutoReason = 12
)

var AutoReason_name = map[int32]string{
	0:  "AUTO_REASON_UNKNOWN",
	1:  "AUTO_REASON_BUDGET_NOT_STARTED",
	2:  "AUTO_REASON_SWEEP_FEES",
	3:  "AUTO_REASON_BUDGET_ELAPSED",
	4:  "AUTO_REASON_IN_FLIGHT",
	5:  "AUTO_REASON_SWAP_FEE",
	6:  "AUTO_REASON_MINER_FEE",
	7:  "AUTO_REASON_PREPAY",
	8:  "AUTO_REASON_FAILURE_BACKOFF",
	9:  "AUTO_REASON_LOOP_OUT",
	10: "AUTO_REASON_LOOP_IN",
	11: "AUTO_REASON_LIQUIDITY_OK",
	12: "AUTO_REASON_BUDGET_INSUFFICIENT",
}

var AutoReason_value = map[string]int32{
	"AUTO_REASON_UNKNOWN":             0,
	"AUTO_REASON_BUDGET_NOT_STARTED":  1,
	"AUTO_REASON_SWEEP_FEES":          2,
	"AUTO_REASON_BUDGET_ELAPSED":      3,
	"AUTO_REASON_IN_FLIGHT":           4,
	"AUTO_REASON_SWAP_FEE":            5,
	"AUTO_REASON_MINER_FEE":           6,
	"AUTO_REASON_PREPAY":              7,
	"AUTO_REASON_FAILURE_BACKOFF":     8,
	"AUTO_REASON_LOOP_OUT":            9,
	"AUTO_REASON_LOOP_IN":             10,
	"AUTO_REASON_LIQUIDITY_OK":        11,
	"AUTO_REASON_BUDGET_INSUFFICIENT": 12,
}

func (x AutoReason) String() string {
	return proto.EnumName(AutoReason_name, int32(x))
}

func (AutoReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{4}
}

type LoopOutRequest struct {
	//
	//Requested swap amount in sat. This does not include the swap and miner fee.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//
	//Base58 encoded destination address for the swap.
	Dest string `protobuf:"bytes,2,opt,name=dest,proto3" json:"dest,omitempty"`
	//
	//Maximum off-chain fee in sat that may be paid for swap payment to the server.
	//This limit is applied during path finding. Typically this value is taken
	//from the response of the GetQuote call.
	MaxSwapRoutingFee int64 `protobuf:"varint,3,opt,name=max_swap_routing_fee,json=maxSwapRoutingFee,proto3" json:"max_swap_routing_fee,omitempty"`
	//
	//Maximum off-chain fee in sat that may be paid for the prepay to the server.
	//This limit is applied during path finding. Typically this value is taken
	//from the response of the GetQuote call.
	MaxPrepayRoutingFee int64 `protobuf:"varint,4,opt,name=max_prepay_routing_fee,json=maxPrepayRoutingFee,proto3" json:"max_prepay_routing_fee,omitempty"`
	//
	//Maximum we are willing to pay the server for the swap. This value is not
	//disclosed in the swap initiation call, but if the server asks for a
	//higher fee, we abort the swap. Typically this value is taken from the
	//response of the GetQuote call. It includes the prepay amount.
	MaxSwapFee int64 `protobuf:"varint,5,opt,name=max_swap_fee,json=maxSwapFee,proto3" json:"max_swap_fee,omitempty"`
	//
	//Maximum amount of the swap fee that may be charged as a prepayment.
	MaxPrepayAmt int64 `protobuf:"varint,6,opt,name=max_prepay_amt,json=maxPrepayAmt,proto3" json:"max_prepay_amt,omitempty"`
	//
	//Maximum in on-chain fees that we are willing to spend. If we want to
	//sweep the on-chain htlc and the fee estimate turns out higher than this
	//value, we cancel the swap. If the fee estimate is lower, we publish the
	//sweep tx.
	//
	//If the sweep tx is not confirmed, we are forced to ratchet up fees until it
	//is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
	//timeout. Because the initial publication revealed the preimage, we have no
	//other choice. The server may already have pulled the off-chain htlc. Only
	//when the fee becomes higher than the swap amount, we can only wait for fees
	//to come down and hope - if we are past the timeout - that the server is not
	//publishing the revocation.
	//
	//max_miner_fee is typically taken from the response of the GetQuote call.
	MaxMinerFee int64 `protobuf:"varint,7,opt,name=max_miner_fee,json=maxMinerFee,proto3" json:"max_miner_fee,omitempty"`
	//
	//Deprecated, use outgoing_chan_set. The channel to loop out, the channel
	//to loop out is selected based on the lowest routing fee for the swap
	//payment to the server.
	LoopOutChannel uint64 `protobuf:"varint,8,opt,name=loop_out_channel,json=loopOutChannel,proto3" json:"loop_out_channel,omitempty"` // Deprecated: Do not use.
	//
	//A restriction on the channel set that may be used to loop out. The actual
	//channel(s) that will be used are selected based on the lowest routing fee
	//for the swap payment to the server.
	OutgoingChanSet []uint64 `protobuf:"varint,11,rep,packed,name=outgoing_chan_set,json=outgoingChanSet,proto3" json:"outgoing_chan_set,omitempty"`
	//
	//The number of blocks from the on-chain HTLC's confirmation height that it
	//should be swept within.
	SweepConfTarget int32 `protobuf:"varint,9,opt,name=sweep_conf_target,json=sweepConfTarget,proto3" json:"sweep_conf_target,omitempty"`
	//
	//The number of confirmations that we require for the on chain htlc that will
	//be published by the server before we reveal the preimage.
	HtlcConfirmations int32 `protobuf:"varint,13,opt,name=htlc_confirmations,json=htlcConfirmations,proto3" json:"htlc_confirmations,omitempty"`
	//
	//The latest time (in unix seconds) we allow the server to wait before
	//publishing the HTLC on chain. Setting this to a larger value will give the
	//server the opportunity to batch multiple swaps together, and wait for
	//low-fee periods before publishing the HTLC, potentially resulting in a
	//lower total swap fee.
	SwapPublicationDeadline uint64 `protobuf:"varint,10,opt,name=swap_publication_deadline,json=swapPublicationDeadline,proto3" json:"swap_publication_deadline,omitempty"`
	//
	//An optional label for this swap. This field is limited to 500 characters
	//and may not start with the prefix [reserved], which is used to tag labels
	//produced by the daemon.
	Label string `protobuf:"bytes,12,opt,name=label,proto3" json:"label,omitempty"`
	//
	//An optional identification string that will be appended to the user agent
	//string sent to the server to give information about the usage of loop. This
	//initiator part is meant for user interfaces to add their name to give the
	//full picture of the binary used (loopd, LiT) and the method used for
	//triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
	Initiator            string   `protobuf:"bytes,14,opt,name=initiator,proto3" json:"initiator,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoopOutRequest) Reset()         { *m = LoopOutRequest{} }
func (m *LoopOutRequest) String() string { return proto.CompactTextString(m) }
func (*LoopOutRequest) ProtoMessage()    {}
func (*LoopOutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{0}
}

func (m *LoopOutRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoopOutRequest.Unmarshal(m, b)
}
func (m *LoopOutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoopOutRequest.Marshal(b, m, deterministic)
}
func (m *LoopOutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopOutRequest.Merge(m, src)
}
func (m *LoopOutRequest) XXX_Size() int {
	return xxx_messageInfo_LoopOutRequest.Size(m)
}
func (m *LoopOutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopOutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoopOutRequest proto.InternalMessageInfo

func (m *LoopOutRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *LoopOutRequest) GetDest() string {
	if m != nil {
		return m.Dest
	}
	return ""
}

func (m *LoopOutRequest) GetMaxSwapRoutingFee() int64 {
	if m != nil {
		return m.MaxSwapRoutingFee
	}
	return 0
}

func (m *LoopOutRequest) GetMaxPrepayRoutingFee() int64 {
	if m != nil {
		return m.MaxPrepayRoutingFee
	}
	return 0
}

func (m *LoopOutRequest) GetMaxSwapFee() int64 {
	if m != nil {
		return m.MaxSwapFee
	}
	return 0
}

func (m *LoopOutRequest) GetMaxPrepayAmt() int64 {
	if m != nil {
		return m.MaxPrepayAmt
	}
	return 0
}

func (m *LoopOutRequest) GetMaxMinerFee() int64 {
	if m != nil {
		return m.MaxMinerFee
	}
	return 0
}

// Deprecated: Do not use.
func (m *LoopOutRequest) GetLoopOutChannel() uint64 {
	if m != nil {
		return m.LoopOutChannel
	}
	return 0
}

func (m *LoopOutRequest) GetOutgoingChanSet() []uint64 {
	if m != nil {
		return m.OutgoingChanSet
	}
	return nil
}

func (m *LoopOutRequest) GetSweepConfTarget() int32 {
	if m != nil {
		return m.SweepConfTarget
	}
	return 0
}

func (m *LoopOutRequest) GetHtlcConfirmations() int32 {
	if m != nil {
		return m.HtlcConfirmations
	}
	return 0
}

func (m *LoopOutRequest) GetSwapPublicationDeadline() uint64 {
	if m != nil {
		return m.SwapPublicationDeadline
	}
	return 0
}

func (m *LoopOutRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *LoopOutRequest) GetInitiator() string {
	if m != nil {
		return m.Initiator
	}
	return ""
}

type LoopInRequest struct {
	//
	//Requested swap amount in sat. This does not include the swap and miner
	//fee.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//
	//Maximum we are willing to pay the server for the swap. This value is not
	//disclosed in the swap initiation call, but if the server asks for a
	//higher fee, we abort the swap. Typically this value is taken from the
	//response of the GetQuote call.
	MaxSwapFee int64 `protobuf:"varint,2,opt,name=max_swap_fee,json=maxSwapFee,proto3" json:"max_swap_fee,omitempty"`
	//
	//Maximum in on-chain fees that we are willing to spend. If we want to
	//publish the on-chain htlc and the fee estimate turns out higher than this
	//value, we cancel the swap.
	//
	//max_miner_fee is typically taken from the response of the GetQuote call.
	MaxMinerFee int64 `protobuf:"varint,3,opt,name=max_miner_fee,json=maxMinerFee,proto3" json:"max_miner_fee,omitempty"`
	//
	//The last hop to use for the loop in swap. If empty, the last hop is selected
	//based on the lowest routing fee for the swap payment from the server.
	LastHop []byte `protobuf:"bytes,4,opt,name=last_hop,json=lastHop,proto3" json:"last_hop,omitempty"`
	//
	//If external_htlc is true, we expect the htlc to be published by an external
	//actor.
	ExternalHtlc bool `protobuf:"varint,5,opt,name=external_htlc,json=externalHtlc,proto3" json:"external_htlc,omitempty"`
	//
	//The number of blocks that the on chain htlc should confirm within.
	HtlcConfTarget int32 `protobuf:"varint,6,opt,name=htlc_conf_target,json=htlcConfTarget,proto3" json:"htlc_conf_target,omitempty"`
	//
	//An optional label for this swap. This field is limited to 500 characters
	//and may not be one of the reserved values in loop/labels Reserved list.
	Label string `protobuf:"bytes,7,opt,name=label,proto3" json:"label,omitempty"`
	//
	//An optional identification string that will be appended to the user agent
	//string sent to the server to give information about the usage of loop. This
	//initiator part is meant for user interfaces to add their name to give the
	//full picture of the binary used (loopd, LiT) and the method used for
	//triggering the swap (loop CLI, autolooper, LiT UI, other 3rd party UI).
	Initiator            string   `protobuf:"bytes,8,opt,name=initiator,proto3" json:"initiator,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoopInRequest) Reset()         { *m = LoopInRequest{} }
func (m *LoopInRequest) String() string { return proto.CompactTextString(m) }
func (*LoopInRequest) ProtoMessage()    {}
func (*LoopInRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{1}
}

func (m *LoopInRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoopInRequest.Unmarshal(m, b)
}
func (m *LoopInRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoopInRequest.Marshal(b, m, deterministic)
}
func (m *LoopInRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopInRequest.Merge(m, src)
}
func (m *LoopInRequest) XXX_Size() int {
	return xxx_messageInfo_LoopInRequest.Size(m)
}
func (m *LoopInRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopInRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoopInRequest proto.InternalMessageInfo

func (m *LoopInRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *LoopInRequest) GetMaxSwapFee() int64 {
	if m != nil {
		return m.MaxSwapFee
	}
	return 0
}

func (m *LoopInRequest) GetMaxMinerFee() int64 {
	if m != nil {
		return m.MaxMinerFee
	}
	return 0
}

func (m *LoopInRequest) GetLastHop() []byte {
	if m != nil {
		return m.LastHop
	}
	return nil
}

func (m *LoopInRequest) GetExternalHtlc() bool {
	if m != nil {
		return m.ExternalHtlc
	}
	return false
}

func (m *LoopInRequest) GetHtlcConfTarget() int32 {
	if m != nil {
		return m.HtlcConfTarget
	}
	return 0
}

func (m *LoopInRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *LoopInRequest) GetInitiator() string {
	if m != nil {
		return m.Initiator
	}
	return ""
}

type SwapResponse struct {
	//
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	//DEPRECATED: To make the API more consistent, this field is deprecated in
	//favor of id_bytes and will be removed in a future release.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // Deprecated: Do not use.
	//
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	IdBytes []byte `protobuf:"bytes,3,opt,name=id_bytes,json=idBytes,proto3" json:"id_bytes,omitempty"`
	//
	//DEPRECATED. This field stores the address of the onchain htlc, but
	//depending on the request, the semantics are different.
	//- For internal loop-in htlc_address contains the address of the
	//native segwit (P2WSH) htlc.
	//- For external loop-in htlc_address contains the address of the
	//nested segwit (NP2WSH) htlc.
	//- For loop-out htlc_address always contains the native segwit (P2WSH)
	//htlc address.
	HtlcAddress string `protobuf:"bytes,2,opt,name=htlc_address,json=htlcAddress,proto3" json:"htlc_address,omitempty"` // Deprecated: Do not use.
	//
	//The nested segwit address of the on-chain htlc.
	//This field remains empty for loop-out.
	HtlcAddressNp2Wsh string `protobuf:"bytes,4,opt,name=htlc_address_np2wsh,json=htlcAddressNp2wsh,proto3" json:"htlc_address_np2wsh,omitempty"`
	//
	//The native segwit address of the on-chain htlc.
	//Used for both loop-in and loop-out.
	HtlcAddressP2Wsh string `protobuf:"bytes,5,opt,name=htlc_address_p2wsh,json=htlcAddressP2wsh,proto3" json:"htlc_address_p2wsh,omitempty"`
	// A human-readable message received from the loop server.
	ServerMessage        string   `protobuf:"bytes,6,opt,name=server_message,json=serverMessage,proto3" json:"server_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapResponse) Reset()         { *m = SwapResponse{} }
func (m *SwapResponse) String() string { return proto.CompactTextString(m) }
func (*SwapResponse) ProtoMessage()    {}
func (*SwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{2}
}

func (m *SwapResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapResponse.Unmarshal(m, b)
}
func (m *SwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapResponse.Marshal(b, m, deterministic)
}
func (m *SwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapResponse.Merge(m, src)
}
func (m *SwapResponse) XXX_Size() int {
	return xxx_messageInfo_SwapResponse.Size(m)
}
func (m *SwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapResponse proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *SwapResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SwapResponse) GetIdBytes() []byte {
	if m != nil {
		return m.IdBytes
	}
	return nil
}

// Deprecated: Do not use.
func (m *SwapResponse) GetHtlcAddress() string {
	if m != nil {
		return m.HtlcAddress
	}
	return ""
}

func (m *SwapResponse) GetHtlcAddressNp2Wsh() string {
	if m != nil {
		return m.HtlcAddressNp2Wsh
	}
	return ""
}

func (m *SwapResponse) GetHtlcAddressP2Wsh() string {
	if m != nil {
		return m.HtlcAddressP2Wsh
	}
	return ""
}

func (m *SwapResponse) GetServerMessage() string {
	if m != nil {
		return m.ServerMessage
	}
	return ""
}

type MonitorRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MonitorRequest) Reset()         { *m = MonitorRequest{} }
func (m *MonitorRequest) String() string { return proto.CompactTextString(m) }
func (*MonitorRequest) ProtoMessage()    {}
func (*MonitorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{3}
}

func (m *MonitorRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MonitorRequest.Unmarshal(m, b)
}
func (m *MonitorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MonitorRequest.Marshal(b, m, deterministic)
}
func (m *MonitorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitorRequest.Merge(m, src)
}
func (m *MonitorRequest) XXX_Size() int {
	return xxx_messageInfo_MonitorRequest.Size(m)
}
func (m *MonitorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MonitorRequest proto.InternalMessageInfo

type SwapStatus struct {
	//
	//Requested swap amount in sat. This does not include the swap and miner
	//fee.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	//DEPRECATED: To make the API more consistent, this field is deprecated in
	//favor of id_bytes and will be removed in a future release.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"` // Deprecated: Do not use.
	//
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	IdBytes []byte `protobuf:"bytes,11,opt,name=id_bytes,json=idBytes,proto3" json:"id_bytes,omitempty"`
	//
	//The type of the swap.
	Type SwapType `protobuf:"varint,3,opt,name=type,proto3,enum=looprpc.SwapType" json:"type,omitempty"`
	//
	//State the swap is currently in, see State enum.
	State SwapState `protobuf:"varint,4,opt,name=state,proto3,enum=looprpc.SwapState" json:"state,omitempty"`
	//
	//A failure reason for the swap, only set if the swap has failed.
	FailureReason FailureReason `protobuf:"varint,14,opt,name=failure_reason,json=failureReason,proto3,enum=looprpc.FailureReason" json:"failure_reason,omitempty"`
	//
	//Initiation time of the swap.
	InitiationTime int64 `protobuf:"varint,5,opt,name=initiation_time,json=initiationTime,proto3" json:"initiation_time,omitempty"`
	//
	//Initiation time of the swap.
	LastUpdateTime int64 `protobuf:"varint,6,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	//
	//DEPRECATED:  This field stores the address of the onchain htlc.
	//- For internal loop-in htlc_address contains the address of the
	//native segwit (P2WSH) htlc.
	//- For external loop-in htlc_address contains the nested segwit (NP2WSH)
	//address.
	//- For loop-out htlc_address always contains the native segwit (P2WSH)
	//htlc address.
	HtlcAddress string `protobuf:"bytes,7,opt,name=htlc_address,json=htlcAddress,proto3" json:"htlc_address,omitempty"` // Deprecated: Do not use.
	// HTLC address (native segwit), used in loop-in and loop-out swaps.
	HtlcAddressP2Wsh string `protobuf:"bytes,12,opt,name=htlc_address_p2wsh,json=htlcAddressP2wsh,proto3" json:"htlc_address_p2wsh,omitempty"`
	// HTLC address (nested segwit), used in loop-in swaps only.
	HtlcAddressNp2Wsh string `protobuf:"bytes,13,opt,name=htlc_address_np2wsh,json=htlcAddressNp2wsh,proto3" json:"htlc_address_np2wsh,omitempty"`
	// Swap server cost
	CostServer int64 `protobuf:"varint,8,opt,name=cost_server,json=costServer,proto3" json:"cost_server,omitempty"`
	// On-chain transaction cost
	CostOnchain int64 `protobuf:"varint,9,opt,name=cost_onchain,json=costOnchain,proto3" json:"cost_onchain,omitempty"`
	// Off-chain routing fees
	CostOffchain int64 `protobuf:"varint,10,opt,name=cost_offchain,json=costOffchain,proto3" json:"cost_offchain,omitempty"`
	// An optional label given to the swap on creation.
	Label                string   `protobuf:"bytes,15,opt,name=label,proto3" json:"label,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapStatus) Reset()         { *m = SwapStatus{} }
func (m *SwapStatus) String() string { return proto.CompactTextString(m) }
func (*SwapStatus) ProtoMessage()    {}
func (*SwapStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{4}
}

func (m *SwapStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapStatus.Unmarshal(m, b)
}
func (m *SwapStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapStatus.Marshal(b, m, deterministic)
}
func (m *SwapStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapStatus.Merge(m, src)
}
func (m *SwapStatus) XXX_Size() int {
	return xxx_messageInfo_SwapStatus.Size(m)
}
func (m *SwapStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SwapStatus proto.InternalMessageInfo

func (m *SwapStatus) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

// Deprecated: Do not use.
func (m *SwapStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SwapStatus) GetIdBytes() []byte {
	if m != nil {
		return m.IdBytes
	}
	return nil
}

func (m *SwapStatus) GetType() SwapType {
	if m != nil {
		return m.Type
	}
	return SwapType_LOOP_OUT
}

func (m *SwapStatus) GetState() SwapState {
	if m != nil {
		return m.State
	}
	return SwapState_INITIATED
}

func (m *SwapStatus) GetFailureReason() FailureReason {
	if m != nil {
		return m.FailureReason
	}
	return FailureReason_FAILURE_REASON_NONE
}

func (m *SwapStatus) GetInitiationTime() int64 {
	if m != nil {
		return m.InitiationTime
	}
	return 0
}

func (m *SwapStatus) GetLastUpdateTime() int64 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

// Deprecated: Do not use.
func (m *SwapStatus) GetHtlcAddress() string {
	if m != nil {
		return m.HtlcAddress
	}
	return ""
}

func (m *SwapStatus) GetHtlcAddressP2Wsh() string {
	if m != nil {
		return m.HtlcAddressP2Wsh
	}
	return ""
}

func (m *SwapStatus) GetHtlcAddressNp2Wsh() string {
	if m != nil {
		return m.HtlcAddressNp2Wsh
	}
	return ""
}

func (m *SwapStatus) GetCostServer() int64 {
	if m != nil {
		return m.CostServer
	}
	return 0
}

func (m *SwapStatus) GetCostOnchain() int64 {
	if m != nil {
		return m.CostOnchain
	}
	return 0
}

func (m *SwapStatus) GetCostOffchain() int64 {
	if m != nil {
		return m.CostOffchain
	}
	return 0
}

func (m *SwapStatus) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type ListSwapsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListSwapsRequest) Reset()         { *m = ListSwapsRequest{} }
func (m *ListSwapsRequest) String() string { return proto.CompactTextString(m) }
func (*ListSwapsRequest) ProtoMessage()    {}
func (*ListSwapsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{5}
}

func (m *ListSwapsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListSwapsRequest.Unmarshal(m, b)
}
func (m *ListSwapsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListSwapsRequest.Marshal(b, m, deterministic)
}
func (m *ListSwapsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSwapsRequest.Merge(m, src)
}
func (m *ListSwapsRequest) XXX_Size() int {
	return xxx_messageInfo_ListSwapsRequest.Size(m)
}
func (m *ListSwapsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSwapsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListSwapsRequest proto.InternalMessageInfo

type ListSwapsResponse struct {
	//
	//The list of all currently known swaps and their status.
	Swaps                []*SwapStatus `protobuf:"bytes,1,rep,name=swaps,proto3" json:"swaps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ListSwapsResponse) Reset()         { *m = ListSwapsResponse{} }
func (m *ListSwapsResponse) String() string { return proto.CompactTextString(m) }
func (*ListSwapsResponse) ProtoMessage()    {}
func (*ListSwapsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{6}
}

func (m *ListSwapsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListSwapsResponse.Unmarshal(m, b)
}
func (m *ListSwapsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListSwapsResponse.Marshal(b, m, deterministic)
}
func (m *ListSwapsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListSwapsResponse.Merge(m, src)
}
func (m *ListSwapsResponse) XXX_Size() int {
	return xxx_messageInfo_ListSwapsResponse.Size(m)
}
func (m *ListSwapsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListSwapsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListSwapsResponse proto.InternalMessageInfo

func (m *ListSwapsResponse) GetSwaps() []*SwapStatus {
	if m != nil {
		return m.Swaps
	}
	return nil
}

type SwapInfoRequest struct {
	//
	//The swap identifier which currently is the hash that locks the HTLCs. When
	//using REST, this field must be encoded as URL safe base64.
	Id                   []byte   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapInfoRequest) Reset()         { *m = SwapInfoRequest{} }
func (m *SwapInfoRequest) String() string { return proto.CompactTextString(m) }
func (*SwapInfoRequest) ProtoMessage()    {}
func (*SwapInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{7}
}

func (m *SwapInfoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapInfoRequest.Unmarshal(m, b)
}
func (m *SwapInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapInfoRequest.Marshal(b, m, deterministic)
}
func (m *SwapInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapInfoRequest.Merge(m, src)
}
func (m *SwapInfoRequest) XXX_Size() int {
	return xxx_messageInfo_SwapInfoRequest.Size(m)
}
func (m *SwapInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwapInfoRequest proto.InternalMessageInfo

func (m *SwapInfoRequest) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type TermsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TermsRequest) Reset()         { *m = TermsRequest{} }
func (m *TermsRequest) String() string { return proto.CompactTextString(m) }
func (*TermsRequest) ProtoMessage()    {}
func (*TermsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{8}
}

func (m *TermsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TermsRequest.Unmarshal(m, b)
}
func (m *TermsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TermsRequest.Marshal(b, m, deterministic)
}
func (m *TermsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TermsRequest.Merge(m, src)
}
func (m *TermsRequest) XXX_Size() int {
	return xxx_messageInfo_TermsRequest.Size(m)
}
func (m *TermsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TermsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TermsRequest proto.InternalMessageInfo

type InTermsResponse struct {
	//
	//Minimum swap amount (sat)
	MinSwapAmount int64 `protobuf:"varint,5,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"`
	//
	//Maximum swap amount (sat)
	MaxSwapAmount        int64    `protobuf:"varint,6,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InTermsResponse) Reset()         { *m = InTermsResponse{} }
func (m *InTermsResponse) String() string { return proto.CompactTextString(m) }
func (*InTermsResponse) ProtoMessage()    {}
func (*InTermsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{9}
}

func (m *InTermsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InTermsResponse.Unmarshal(m, b)
}
func (m *InTermsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InTermsResponse.Marshal(b, m, deterministic)
}
func (m *InTermsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InTermsResponse.Merge(m, src)
}
func (m *InTermsResponse) XXX_Size() int {
	return xxx_messageInfo_InTermsResponse.Size(m)
}
func (m *InTermsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InTermsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InTermsResponse proto.InternalMessageInfo

func (m *InTermsResponse) GetMinSwapAmount() int64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

func (m *InTermsResponse) GetMaxSwapAmount() int64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

type OutTermsResponse struct {
	//
	//Minimum swap amount (sat)
	MinSwapAmount int64 `protobuf:"varint,5,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"`
	//
	//Maximum swap amount (sat)
	MaxSwapAmount int64 `protobuf:"varint,6,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"`
	// The minimally accepted cltv delta of the on-chain htlc.
	MinCltvDelta int32 `protobuf:"varint,8,opt,name=min_cltv_delta,json=minCltvDelta,proto3" json:"min_cltv_delta,omitempty"`
	// The maximally accepted cltv delta of the on-chain htlc.
	MaxCltvDelta         int32    `protobuf:"varint,9,opt,name=max_cltv_delta,json=maxCltvDelta,proto3" json:"max_cltv_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutTermsResponse) Reset()         { *m = OutTermsResponse{} }
func (m *OutTermsResponse) String() string { return proto.CompactTextString(m) }
func (*OutTermsResponse) ProtoMessage()    {}
func (*OutTermsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{10}
}

func (m *OutTermsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutTermsResponse.Unmarshal(m, b)
}
func (m *OutTermsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutTermsResponse.Marshal(b, m, deterministic)
}
func (m *OutTermsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutTermsResponse.Merge(m, src)
}
func (m *OutTermsResponse) XXX_Size() int {
	return xxx_messageInfo_OutTermsResponse.Size(m)
}
func (m *OutTermsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OutTermsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OutTermsResponse proto.InternalMessageInfo

func (m *OutTermsResponse) GetMinSwapAmount() int64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

func (m *OutTermsResponse) GetMaxSwapAmount() int64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

func (m *OutTermsResponse) GetMinCltvDelta() int32 {
	if m != nil {
		return m.MinCltvDelta
	}
	return 0
}

func (m *OutTermsResponse) GetMaxCltvDelta() int32 {
	if m != nil {
		return m.MaxCltvDelta
	}
	return 0
}

type QuoteRequest struct {
	//
	//The amount to swap in satoshis.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//
	//The confirmation target that should be used either for the sweep of the
	//on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
	//the confirmation of the on-chain HTLC broadcast by the swap client in the
	//case of a Loop In.
	ConfTarget int32 `protobuf:"varint,2,opt,name=conf_target,json=confTarget,proto3" json:"conf_target,omitempty"`
	//
	//If external_htlc is true, we expect the htlc to be published by an external
	//actor.
	ExternalHtlc bool `protobuf:"varint,3,opt,name=external_htlc,json=externalHtlc,proto3" json:"external_htlc,omitempty"`
	//
	//The latest time (in unix seconds) we allow the server to wait before
	//publishing the HTLC on chain. Setting this to a larger value will give the
	//server the opportunity to batch multiple swaps together, and wait for
	//low-fee periods before publishing the HTLC, potentially resulting in a
	//lower total swap fee. This only has an effect on loop out quotes.
	SwapPublicationDeadline uint64   `protobuf:"varint,4,opt,name=swap_publication_deadline,json=swapPublicationDeadline,proto3" json:"swap_publication_deadline,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *QuoteRequest) Reset()         { *m = QuoteRequest{} }
func (m *QuoteRequest) String() string { return proto.CompactTextString(m) }
func (*QuoteRequest) ProtoMessage()    {}
func (*QuoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{11}
}

func (m *QuoteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QuoteRequest.Unmarshal(m, b)
}
func (m *QuoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QuoteRequest.Marshal(b, m, deterministic)
}
func (m *QuoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuoteRequest.Merge(m, src)
}
func (m *QuoteRequest) XXX_Size() int {
	return xxx_messageInfo_QuoteRequest.Size(m)
}
func (m *QuoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuoteRequest proto.InternalMessageInfo

func (m *QuoteRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *QuoteRequest) GetConfTarget() int32 {
	if m != nil {
		return m.ConfTarget
	}
	return 0
}

func (m *QuoteRequest) GetExternalHtlc() bool {
	if m != nil {
		return m.ExternalHtlc
	}
	return false
}

func (m *QuoteRequest) GetSwapPublicationDeadline() uint64 {
	if m != nil {
		return m.SwapPublicationDeadline
	}
	return 0
}

type InQuoteResponse struct {
	//
	//The fee that the swap server is charging for the swap.
	SwapFeeSat int64 `protobuf:"varint,1,opt,name=swap_fee_sat,json=swapFeeSat,proto3" json:"swap_fee_sat,omitempty"`
	//
	//An estimate of the on-chain fee that needs to be paid to publish the HTLC
	//If a miner fee of 0 is returned, it means the external_htlc flag was set for
	//a loop in and the fee estimation was skipped. If a miner fee of -1 is
	//returned, it means lnd's wallet tried to estimate the fee but was unable to
	//create a sample estimation transaction because not enough funds are
	//available. An information message should be shown to the user in this case.
	HtlcPublishFeeSat int64 `protobuf:"varint,3,opt,name=htlc_publish_fee_sat,json=htlcPublishFeeSat,proto3" json:"htlc_publish_fee_sat,omitempty"`
	//
	//On-chain cltv expiry delta
	CltvDelta            int32    `protobuf:"varint,5,opt,name=cltv_delta,json=cltvDelta,proto3" json:"cltv_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InQuoteResponse) Reset()         { *m = InQuoteResponse{} }
func (m *InQuoteResponse) String() string { return proto.CompactTextString(m) }
func (*InQuoteResponse) ProtoMessage()    {}
func (*InQuoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{12}
}

func (m *InQuoteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InQuoteResponse.Unmarshal(m, b)
}
func (m *InQuoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InQuoteResponse.Marshal(b, m, deterministic)
}
func (m *InQuoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InQuoteResponse.Merge(m, src)
}
func (m *InQuoteResponse) XXX_Size() int {
	return xxx_messageInfo_InQuoteResponse.Size(m)
}
func (m *InQuoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InQuoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InQuoteResponse proto.InternalMessageInfo

func (m *InQuoteResponse) GetSwapFeeSat() int64 {
	if m != nil {
		return m.SwapFeeSat
	}
	return 0
}

func (m *InQuoteResponse) GetHtlcPublishFeeSat() int64 {
	if m != nil {
		return m.HtlcPublishFeeSat
	}
	return 0
}

func (m *InQuoteResponse) GetCltvDelta() int32 {
	if m != nil {
		return m.CltvDelta
	}
	return 0
}

type OutQuoteResponse struct {
	//
	//The fee that the swap server is charging for the swap.
	SwapFeeSat int64 `protobuf:"varint,1,opt,name=swap_fee_sat,json=swapFeeSat,proto3" json:"swap_fee_sat,omitempty"`
	//
	//The part of the swap fee that is requested as a prepayment.
	PrepayAmtSat int64 `protobuf:"varint,2,opt,name=prepay_amt_sat,json=prepayAmtSat,proto3" json:"prepay_amt_sat,omitempty"`
	//
	//An estimate of the on-chain fee that needs to be paid to sweep the HTLC for
	//a loop out.
	HtlcSweepFeeSat int64 `protobuf:"varint,3,opt,name=htlc_sweep_fee_sat,json=htlcSweepFeeSat,proto3" json:"htlc_sweep_fee_sat,omitempty"`
	//
	//The node pubkey where the swap payment needs to be paid
	//to. This can be used to test connectivity before initiating the swap.
	SwapPaymentDest []byte `protobuf:"bytes,4,opt,name=swap_payment_dest,json=swapPaymentDest,proto3" json:"swap_payment_dest,omitempty"`
	//
	//On-chain cltv expiry delta
	CltvDelta            int32    `protobuf:"varint,5,opt,name=cltv_delta,json=cltvDelta,proto3" json:"cltv_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OutQuoteResponse) Reset()         { *m = OutQuoteResponse{} }
func (m *OutQuoteResponse) String() string { return proto.CompactTextString(m) }
func (*OutQuoteResponse) ProtoMessage()    {}
func (*OutQuoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{13}
}

func (m *OutQuoteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutQuoteResponse.Unmarshal(m, b)
}
func (m *OutQuoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutQuoteResponse.Marshal(b, m, deterministic)
}
func (m *OutQuoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutQuoteResponse.Merge(m, src)
}
func (m *OutQuoteResponse) XXX_Size() int {
	return xxx_messageInfo_OutQuoteResponse.Size(m)
}
func (m *OutQuoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OutQuoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OutQuoteResponse proto.InternalMessageInfo

func (m *OutQuoteResponse) GetSwapFeeSat() int64 {
	if m != nil {
		return m.SwapFeeSat
	}
	return 0
}

func (m *OutQuoteResponse) GetPrepayAmtSat() int64 {
	if m != nil {
		return m.PrepayAmtSat
	}
	return 0
}

func (m *OutQuoteResponse) GetHtlcSweepFeeSat() int64 {
	if m != nil {
		return m.HtlcSweepFeeSat
	}
	return 0
}

func (m *OutQuoteResponse) GetSwapPaymentDest() []byte {
	if m != nil {
		return m.SwapPaymentDest
	}
	return nil
}

func (m *OutQuoteResponse) GetCltvDelta() int32 {
	if m != nil {
		return m.CltvDelta
	}
	return 0
}

type TokensRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TokensRequest) Reset()         { *m = TokensRequest{} }
func (m *TokensRequest) String() string { return proto.CompactTextString(m) }
func (*TokensRequest) ProtoMessage()    {}
func (*TokensRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{14}
}

func (m *TokensRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokensRequest.Unmarshal(m, b)
}
func (m *TokensRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokensRequest.Marshal(b, m, deterministic)
}
func (m *TokensRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokensRequest.Merge(m, src)
}
func (m *TokensRequest) XXX_Size() int {
	return xxx_messageInfo_TokensRequest.Size(m)
}
func (m *TokensRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TokensRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TokensRequest proto.InternalMessageInfo

type TokensResponse struct {
	//
	//List of all tokens the daemon knows of, including old/expired tokens.
	Tokens               []*LsatToken `protobuf:"bytes,1,rep,name=tokens,proto3" json:"tokens,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TokensResponse) Reset()         { *m = TokensResponse{} }
func (m *TokensResponse) String() string { return proto.CompactTextString(m) }
func (*TokensResponse) ProtoMessage()    {}
func (*TokensResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{15}
}

func (m *TokensResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TokensResponse.Unmarshal(m, b)
}
func (m *TokensResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TokensResponse.Marshal(b, m, deterministic)
}
func (m *TokensResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokensResponse.Merge(m, src)
}
func (m *TokensResponse) XXX_Size() int {
	return xxx_messageInfo_TokensResponse.Size(m)
}
func (m *TokensResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TokensResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TokensResponse proto.InternalMessageInfo

func (m *TokensResponse) GetTokens() []*LsatToken {
	if m != nil {
		return m.Tokens
	}
	return nil
}

type LsatToken struct {
	//
	//The base macaroon that was baked by the auth server.
	BaseMacaroon []byte `protobuf:"bytes,1,opt,name=base_macaroon,json=baseMacaroon,proto3" json:"base_macaroon,omitempty"`
	//
	//The payment hash of the payment that was paid to obtain the token.
	PaymentHash []byte `protobuf:"bytes,2,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty"`
	//
	//The preimage of the payment hash, knowledge of this is proof that the
	//payment has been paid. If the preimage is set to all zeros, this means the
	//payment is still pending and the token is not yet fully valid.
	PaymentPreimage []byte `protobuf:"bytes,3,opt,name=payment_preimage,json=paymentPreimage,proto3" json:"payment_preimage,omitempty"`
	//
	//The amount of millisatoshis that was paid to get the token.
	AmountPaidMsat int64 `protobuf:"varint,4,opt,name=amount_paid_msat,json=amountPaidMsat,proto3" json:"amount_paid_msat,omitempty"`
	//
	//The amount of millisatoshis paid in routing fee to pay for the token.
	RoutingFeePaidMsat int64 `protobuf:"varint,5,opt,name=routing_fee_paid_msat,json=routingFeePaidMsat,proto3" json:"routing_fee_paid_msat,omitempty"`
	//
	//The creation time of the token as UNIX timestamp in seconds.
	TimeCreated int64 `protobuf:"varint,6,opt,name=time_created,json=timeCreated,proto3" json:"time_created,omitempty"`
	//
	//Indicates whether the token is expired or still valid.
	Expired bool `protobuf:"varint,7,opt,name=expired,proto3" json:"expired,omitempty"`
	//
	//Identifying attribute of this token in the store. Currently represents the
	//file name of the token where it's stored on the file system.
	StorageName          string   `protobuf:"bytes,8,opt,name=storage_name,json=storageName,proto3" json:"storage_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LsatToken) Reset()         { *m = LsatToken{} }
func (m *LsatToken) String() string { return proto.CompactTextString(m) }
func (*LsatToken) ProtoMessage()    {}
func (*LsatToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{16}
}

func (m *LsatToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LsatToken.Unmarshal(m, b)
}
func (m *LsatToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LsatToken.Marshal(b, m, deterministic)
}
func (m *LsatToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LsatToken.Merge(m, src)
}
func (m *LsatToken) XXX_Size() int {
	return xxx_messageInfo_LsatToken.Size(m)
}
func (m *LsatToken) XXX_DiscardUnknown() {
	xxx_messageInfo_LsatToken.DiscardUnknown(m)
}

var xxx_messageInfo_LsatToken proto.InternalMessageInfo

func (m *LsatToken) GetBaseMacaroon() []byte {
	if m != nil {
		return m.BaseMacaroon
	}
	return nil
}

func (m *LsatToken) GetPaymentHash() []byte {
	if m != nil {
		return m.PaymentHash
	}
	return nil
}

func (m *LsatToken) GetPaymentPreimage() []byte {
	if m != nil {
		return m.PaymentPreimage
	}
	return nil
}

func (m *LsatToken) GetAmountPaidMsat() int64 {
	if m != nil {
		return m.AmountPaidMsat
	}
	return 0
}

func (m *LsatToken) GetRoutingFeePaidMsat() int64 {
	if m != nil {
		return m.RoutingFeePaidMsat
	}
	return 0
}

func (m *LsatToken) GetTimeCreated() int64 {
	if m != nil {
		return m.TimeCreated
	}
	return 0
}

func (m *LsatToken) GetExpired() bool {
	if m != nil {
		return m.Expired
	}
	return false
}

func (m *LsatToken) GetStorageName() string {
	if m != nil {
		return m.StorageName
	}
	return ""
}

type GetLiquidityParamsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLiquidityParamsRequest) Reset()         { *m = GetLiquidityParamsRequest{} }
func (m *GetLiquidityParamsRequest) String() string { return proto.CompactTextString(m) }
func (*GetLiquidityParamsRequest) ProtoMessage()    {}
func (*GetLiquidityParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{17}
}

func (m *GetLiquidityParamsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLiquidityParamsRequest.Unmarshal(m, b)
}
func (m *GetLiquidityParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLiquidityParamsRequest.Marshal(b, m, deterministic)
}
func (m *GetLiquidityParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLiquidityParamsRequest.Merge(m, src)
}
func (m *GetLiquidityParamsRequest) XXX_Size() int {
	return xxx_messageInfo_GetLiquidityParamsRequest.Size(m)
}
func (m *GetLiquidityParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLiquidityParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLiquidityParamsRequest proto.InternalMessageInfo

type LiquidityParameters struct {
	//
	//A set of liquidity rules that describe the desired liquidity balance.
	Rules []*LiquidityRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	//
	//The limit we place on our estimated sweep cost for a swap in sat/vByte. If
	//the estimated fee for our sweep transaction within the specified
	//confirmation target is above this value, we will not suggest any swaps.
	SweepFeeRateSatPerVbyte uint64 `protobuf:"varint,2,opt,name=sweep_fee_rate_sat_per_vbyte,json=sweepFeeRateSatPerVbyte,proto3" json:"sweep_fee_rate_sat_per_vbyte,omitempty"`
	//
	//The maximum fee paid to the server for facilitating the swap, expressed
	//as parts per million of the swap volume.
	MaxSwapFeePpm uint64 `protobuf:"varint,3,opt,name=max_swap_fee_ppm,json=maxSwapFeePpm,proto3" json:"max_swap_fee_ppm,omitempty"`
	//
	//The maximum fee paid to route the swap invoice off chain, expressed as
	//parts per million of the volume being routed.
	MaxRoutingFeePpm uint64 `protobuf:"varint,4,opt,name=max_routing_fee_ppm,json=maxRoutingFeePpm,proto3" json:"max_routing_fee_ppm,omitempty"`
	//
	//The maximum fee paid to route the prepay invoice off chain, expressed as
	//parts per million of the volume being routed.
	MaxPrepayRoutingFeePpm uint64 `protobuf:"varint,5,opt,name=max_prepay_routing_fee_ppm,json=maxPrepayRoutingFeePpm,proto3" json:"max_prepay_routing_fee_ppm,omitempty"`
	//
	//The maximum no-show penalty in satoshis paid for a swap.
	MaxPrepaySat uint64 `protobuf:"varint,6,opt,name=max_prepay_sat,json=maxPrepaySat,proto3" json:"max_prepay_sat,omitempty"`
	//
	//The maximum miner fee we will pay to sweep the swap on chain. Note that we
	//will not suggest a swap if the estimate is above the sweep limit set by
	//these parameters, and we use the current fee estimate to sweep on chain so
	//this value is only a cap placed on the amount we spend on fees in the case
	//where the swap needs to be claimed on chain, but fees have suddenly spiked.
	MaxMinerFeeSat uint64 `protobuf:"varint,7,opt,name=max_miner_fee_sat,json=maxMinerFeeSat,proto3" json:"max_miner_fee_sat,omitempty"`
	//
	//The number of blocks from the on-chain HTLC's confirmation height that it
	//should be swept within.
	SweepConfTarget int32 `protobuf:"varint,8,opt,name=sweep_conf_target,json=sweepConfTarget,proto3" json:"sweep_conf_target,omitempty"`
	//
	//The amount of time we require pass since a channel was part of a failed
	//swap due to off chain payment failure until it will be considered for swap
	//suggestions again, expressed in seconds.
	FailureBackoffSec uint64 `protobuf:"varint,9,opt,name=failure_backoff_sec,json=failureBackoffSec,proto3" json:"failure_backoff_sec,omitempty"`
	//
	//Set to true to enable automatic dispatch of swaps. All swaps will be limited
	//to the fee categories set by these parameters, and total expenditure will
	//be limited to the autoloop budget.
	Autoloop bool `protobuf:"varint,10,opt,name=autoloop,proto3" json:"autoloop,omitempty"`
	//
	//The total budget for automatically dispatched swaps since the budget start
	//time, expressed in satoshis.
	AutoloopBudgetSat uint64 `protobuf:"varint,11,opt,name=autoloop_budget_sat,json=autoloopBudgetSat,proto3" json:"autoloop_budget_sat,omitempty"`
	//
	//The start time for autoloop budget, expressed as a unix timestamp in
	//seconds. If this value is 0, the budget will be applied for all
	//automatically dispatched swaps. Swaps that were completed before this date
	//will not be included in budget calculations.
	AutoloopBudgetStartSec uint64 `protobuf:"varint,12,opt,name=autoloop_budget_start_sec,json=autoloopBudgetStartSec,proto3" json:"autoloop_budget_start_sec,omitempty"`
	//
	//The maximum number of automatically dispatched swaps that we allow to be in
	//flight at any point in time.
	AutoMaxInFlight uint64 `protobuf:"varint,13,opt,name=auto_max_in_flight,json=autoMaxInFlight,proto3" json:"auto_max_in_flight,omitempty"`
	//
	//The minimum amount, expressed in satoshis, that the autoloop client will
	//dispatch a swap for. This value is subject to the server-side limits
	//specified by the LoopOutTerms endpoint.
	MinSwapAmount uint64 `protobuf:"varint,14,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"`
	//
	//The maximum amount, expressed in satoshis, that the autoloop client will
	//dispatch a swap for. This value is subject to the server-side limits
	//specified by the LoopOutTerms endpoint.
	MaxSwapAmount        uint64   `protobuf:"varint,15,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LiquidityParameters) Reset()         { *m = LiquidityParameters{} }
func (m *LiquidityParameters) String() string { return proto.CompactTextString(m) }
func (*LiquidityParameters) ProtoMessage()    {}
func (*LiquidityParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{18}
}

func (m *LiquidityParameters) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LiquidityParameters.Unmarshal(m, b)
}
func (m *LiquidityParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LiquidityParameters.Marshal(b, m, deterministic)
}
func (m *LiquidityParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityParameters.Merge(m, src)
}
func (m *LiquidityParameters) XXX_Size() int {
	return xxx_messageInfo_LiquidityParameters.Size(m)
}
func (m *LiquidityParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityParameters.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityParameters proto.InternalMessageInfo

func (m *LiquidityParameters) GetRules() []*LiquidityRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *LiquidityParameters) GetSweepFeeRateSatPerVbyte() uint64 {
	if m != nil {
		return m.SweepFeeRateSatPerVbyte
	}
	return 0
}

func (m *LiquidityParameters) GetMaxSwapFeePpm() uint64 {
	if m != nil {
		return m.MaxSwapFeePpm
	}
	return 0
}

func (m *LiquidityParameters) GetMaxRoutingFeePpm() uint64 {
	if m != nil {
		return m.MaxRoutingFeePpm
	}
	return 0
}

func (m *LiquidityParameters) GetMaxPrepayRoutingFeePpm() uint64 {
	if m != nil {
		return m.MaxPrepayRoutingFeePpm
	}
	return 0
}

func (m *LiquidityParameters) GetMaxPrepaySat() uint64 {
	if m != nil {
		return m.MaxPrepaySat
	}
	return 0
}

func (m *LiquidityParameters) GetMaxMinerFeeSat() uint64 {
	if m != nil {
		return m.MaxMinerFeeSat
	}
	return 0
}

func (m *LiquidityParameters) GetSweepConfTarget() int32 {
	if m != nil {
		return m.SweepConfTarget
	}
	return 0
}

func (m *LiquidityParameters) GetFailureBackoffSec() uint64 {
	if m != nil {
		return m.FailureBackoffSec
	}
	return 0
}

func (m *LiquidityParameters) GetAutoloop() bool {
	if m != nil {
		return m.Autoloop
	}
	return false
}

func (m *LiquidityParameters) GetAutoloopBudgetSat() uint64 {
	if m != nil {
		return m.AutoloopBudgetSat
	}
	return 0
}

func (m *LiquidityParameters) GetAutoloopBudgetStartSec() uint64 {
	if m != nil {
		return m.AutoloopBudgetStartSec
	}
	return 0
}

func (m *LiquidityParameters) GetAutoMaxInFlight() uint64 {
	if m != nil {
		return m.AutoMaxInFlight
	}
	return 0
}

func (m *LiquidityParameters) GetMinSwapAmount() uint64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

func (m *LiquidityParameters) GetMaxSwapAmount() uint64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

type LiquidityRule struct {
	//
	//The short channel ID of the channel that this rule should be applied to.
	//This field may not be set when the pubkey field is set.
	ChannelId uint64 `protobuf:"varint,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	//
	//The public key of the peer that this rule should be applied to. This field
	//may not be set when the channel id field is set.
	Pubkey []byte `protobuf:"bytes,5,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	//
	//Type indicates the type of rule that this message rule represents. Setting
	//this value will determine which fields are used in the message. The comments
	//on each field in this message will be prefixed with the LiquidityRuleType
	//they belong to.
	Type LiquidityRuleType `protobuf:"varint,2,opt,name=type,proto3,enum=looprpc.LiquidityRuleType" json:"type,omitempty"`
	//
	//THRESHOLD: The percentage of total capacity that incoming capacity should
	//not drop beneath.
	IncomingThreshold uint32 `protobuf:"varint,3,opt,name=incoming_threshold,json=incomingThreshold,proto3" json:"incoming_threshold,omitempty"`
	//
	//THRESHOLD: The percentage of total capacity that outgoing capacity should
	//not drop beneath.
	OutgoingThreshold    uint32   `protobuf:"varint,4,opt,name=outgoing_threshold,json=outgoingThreshold,proto3" json:"outgoing_threshold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LiquidityRule) Reset()         { *m = LiquidityRule{} }
func (m *LiquidityRule) String() string { return proto.CompactTextString(m) }
func (*LiquidityRule) ProtoMessage()    {}
func (*LiquidityRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{19}
}

func (m *LiquidityRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LiquidityRule.Unmarshal(m, b)
}
func (m *LiquidityRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LiquidityRule.Marshal(b, m, deterministic)
}
func (m *LiquidityRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityRule.Merge(m, src)
}
func (m *LiquidityRule) XXX_Size() int {
	return xxx_messageInfo_LiquidityRule.Size(m)
}
func (m *LiquidityRule) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityRule.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityRule proto.InternalMessageInfo

func (m *LiquidityRule) GetChannelId() uint64 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *LiquidityRule) GetPubkey() []byte {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

func (m *LiquidityRule) GetType() LiquidityRuleType {
	if m != nil {
		return m.Type
	}
	return LiquidityRuleType_UNKNOWN
}

func (m *LiquidityRule) GetIncomingThreshold() uint32 {
	if m != nil {
		return m.IncomingThreshold
	}
	return 0
}

func (m *LiquidityRule) GetOutgoingThreshold() uint32 {
	if m != nil {
		return m.OutgoingThreshold
	}
	return 0
}

type SetLiquidityParamsRequest struct {
	//
	//Parameters is the desired new set of parameters for the liquidity management
	//subsystem. Note that the current set of parameters will be completely
	//overwritten by the parameters provided (if they are valid), so the full set
	//of parameters should be provided for each call.
	Parameters           *LiquidityParameters `protobuf:"bytes,1,opt,name=parameters,proto3" json:"parameters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SetLiquidityParamsRequest) Reset()         { *m = SetLiquidityParamsRequest{} }
func (m *SetLiquidityParamsRequest) String() string { return proto.CompactTextString(m) }
func (*SetLiquidityParamsRequest) ProtoMessage()    {}
func (*SetLiquidityParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{20}
}

func (m *SetLiquidityParamsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetLiquidityParamsRequest.Unmarshal(m, b)
}
func (m *SetLiquidityParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetLiquidityParamsRequest.Marshal(b, m, deterministic)
}
func (m *SetLiquidityParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetLiquidityParamsRequest.Merge(m, src)
}
func (m *SetLiquidityParamsRequest) XXX_Size() int {
	return xxx_messageInfo_SetLiquidityParamsRequest.Size(m)
}
func (m *SetLiquidityParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetLiquidityParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetLiquidityParamsRequest proto.InternalMessageInfo

func (m *SetLiquidityParamsRequest) GetParameters() *LiquidityParameters {
	if m != nil {
		return m.Parameters
	}
	return nil
}

type SetLiquidityParamsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetLiquidityParamsResponse) Reset()         { *m = SetLiquidityParamsResponse{} }
func (m *SetLiquidityParamsResponse) String() string { return proto.CompactTextString(m) }
func (*SetLiquidityParamsResponse) ProtoMessage()    {}
func (*SetLiquidityParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{21}
}

func (m *SetLiquidityParamsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetLiquidityParamsResponse.Unmarshal(m, b)
}
func (m *SetLiquidityParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetLiquidityParamsResponse.Marshal(b, m, deterministic)
}
func (m *SetLiquidityParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetLiquidityParamsResponse.Merge(m, src)
}
func (m *SetLiquidityParamsResponse) XXX_Size() int {
	return xxx_messageInfo_SetLiquidityParamsResponse.Size(m)
}
func (m *SetLiquidityParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetLiquidityParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetLiquidityParamsResponse proto.InternalMessageInfo

type SuggestSwapsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SuggestSwapsRequest) Reset()         { *m = SuggestSwapsRequest{} }
func (m *SuggestSwapsRequest) String() string { return proto.CompactTextString(m) }
func (*SuggestSwapsRequest) ProtoMessage()    {}
func (*SuggestSwapsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{22}
}

func (m *SuggestSwapsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SuggestSwapsRequest.Unmarshal(m, b)
}
func (m *SuggestSwapsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SuggestSwapsRequest.Marshal(b, m, deterministic)
}
func (m *SuggestSwapsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuggestSwapsRequest.Merge(m, src)
}
func (m *SuggestSwapsRequest) XXX_Size() int {
	return xxx_messageInfo_SuggestSwapsRequest.Size(m)
}
func (m *SuggestSwapsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SuggestSwapsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SuggestSwapsRequest proto.InternalMessageInfo

type Disqualified struct {
	//
	//The short channel ID of the channel that was excluded from our suggestions.
	ChannelId uint64 `protobuf:"varint,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	//
	//The public key of the peer that was excluded from our suggestions.
	Pubkey []byte `protobuf:"bytes,3,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	//
	//The reason that we excluded the channel from the our suggestions.
	Reason               AutoReason `protobuf:"varint,2,opt,name=reason,proto3,enum=looprpc.AutoReason" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Disqualified) Reset()         { *m = Disqualified{} }
func (m *Disqualified) String() string { return proto.CompactTextString(m) }
func (*Disqualified) ProtoMessage()    {}
func (*Disqualified) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{23}
}

func (m *Disqualified) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Disqualified.Unmarshal(m, b)
}
func (m *Disqualified) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Disqualified.Marshal(b, m, deterministic)
}
func (m *Disqualified) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Disqualified.Merge(m, src)
}
func (m *Disqualified) XXX_Size() int {
	return xxx_messageInfo_Disqualified.Size(m)
}
func (m *Disqualified) XXX_DiscardUnknown() {
	xxx_messageInfo_Disqualified.DiscardUnknown(m)
}

var xxx_messageInfo_Disqualified proto.InternalMessageInfo

func (m *Disqualified) GetChannelId() uint64 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *Disqualified) GetPubkey() []byte {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

func (m *Disqualified) GetReason() AutoReason {
	if m != nil {
		return m.Reason
	}
	return AutoReason_AUTO_REASON_UNKNOWN
}

type SuggestSwapsResponse struct {
	//
	//The set of recommended loop outs.
	LoopOut []*LoopOutRequest `protobuf:"bytes,1,rep,name=loop_out,json=loopOut,proto3" json:"loop_out,omitempty"`
	//
	//Disqualified contains the set of channels that swaps are not recommended
	//for.
	Disqualified         []*Disqualified `protobuf:"bytes,2,rep,name=disqualified,proto3" json:"disqualified,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SuggestSwapsResponse) Reset()         { *m = SuggestSwapsResponse{} }
func (m *SuggestSwapsResponse) String() string { return proto.CompactTextString(m) }
func (*SuggestSwapsResponse) ProtoMessage()    {}
func (*SuggestSwapsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{24}
}

func (m *SuggestSwapsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SuggestSwapsResponse.Unmarshal(m, b)
}
func (m *SuggestSwapsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SuggestSwapsResponse.Marshal(b, m, deterministic)
}
func (m *SuggestSwapsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SuggestSwapsResponse.Merge(m, src)
}
func (m *SuggestSwapsResponse) XXX_Size() int {
	return xxx_messageInfo_SuggestSwapsResponse.Size(m)
}
func (m *SuggestSwapsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SuggestSwapsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SuggestSwapsResponse proto.InternalMessageInfo

func (m *SuggestSwapsResponse) GetLoopOut() []*LoopOutRequest {
	if m != nil {
		return m.LoopOut
	}
	return nil
}

func (m *SuggestSwapsResponse) GetDisqualified() []*Disqualified {
	if m != nil {
		return m.Disqualified
	}
	return nil
}

func init() {
	proto.RegisterEnum("looprpc.SwapType", SwapType_name, SwapType_value)
	proto.RegisterEnum("looprpc.SwapState", SwapState_name, SwapState_value)
	proto.RegisterEnum("looprpc.FailureReason", FailureReason_name, FailureReason_value)
	proto.RegisterEnum("looprpc.LiquidityRuleType", LiquidityRuleType_name, LiquidityRuleType_value)
	proto.RegisterEnum("looprpc.AutoReason", AutoReason_name, AutoReason_value)
	proto.RegisterType((*LoopOutRequest)(nil), "looprpc.LoopOutRequest")
	proto.RegisterType((*LoopInRequest)(nil), "looprpc.LoopInRequest")
	proto.RegisterType((*SwapResponse)(nil), "looprpc.SwapResponse")
	proto.RegisterType((*MonitorRequest)(nil), "looprpc.MonitorRequest")
	proto.RegisterType((*SwapStatus)(nil), "looprpc.SwapStatus")
	proto.RegisterType((*ListSwapsRequest)(nil), "looprpc.ListSwapsRequest")
	proto.RegisterType((*ListSwapsResponse)(nil), "looprpc.ListSwapsResponse")
	proto.RegisterType((*SwapInfoRequest)(nil), "looprpc.SwapInfoRequest")
	proto.RegisterType((*TermsRequest)(nil), "looprpc.TermsRequest")
	proto.RegisterType((*InTermsResponse)(nil), "looprpc.InTermsResponse")
	proto.RegisterType((*OutTermsResponse)(nil), "looprpc.OutTermsResponse")
	proto.RegisterType((*QuoteRequest)(nil), "looprpc.QuoteRequest")
	proto.RegisterType((*InQuoteResponse)(nil), "looprpc.InQuoteResponse")
	proto.RegisterType((*OutQuoteResponse)(nil), "looprpc.OutQuoteResponse")
	proto.RegisterType((*TokensRequest)(nil), "looprpc.TokensRequest")
	proto.RegisterType((*TokensResponse)(nil), "looprpc.TokensResponse")
	proto.RegisterType((*LsatToken)(nil), "looprpc.LsatToken")
	proto.RegisterType((*GetLiquidityParamsRequest)(nil), "looprpc.GetLiquidityParamsRequest")
	proto.RegisterType((*LiquidityParameters)(nil), "looprpc.LiquidityParameters")
	proto.RegisterType((*LiquidityRule)(nil), "looprpc.LiquidityRule")
	proto.RegisterType((*SetLiquidityParamsRequest)(nil), "looprpc.SetLiquidityParamsRequest")
	proto.RegisterType((*SetLiquidityParamsResponse)(nil), "looprpc.SetLiquidityParamsResponse")
	proto.RegisterType((*SuggestSwapsRequest)(nil), "looprpc.SuggestSwapsRequest")
	proto.RegisterType((*Disqualified)(nil), "looprpc.Disqualified")
	proto.RegisterType((*SuggestSwapsResponse)(nil), "looprpc.SuggestSwapsResponse")
}

func init() { proto.RegisterFile("client.proto", fileDescriptor_014de31d7ac8c57c) }

var fileDescriptor_014de31d7ac8c57c = []byte{
	// 2624 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0x4f, 0x73, 0xe3, 0xc6,
	0xb1, 0x5f, 0xfe, 0x13, 0xc9, 0x26, 0x48, 0x42, 0xa3, 0x5d, 0x89, 0xa2, 0x65, 0xaf, 0x16, 0xf6,
	0x3e, 0xcb, 0xb2, 0xbd, 0x7a, 0x96, 0x4f, 0x76, 0xd9, 0xaf, 0x8a, 0xa2, 0xa0, 0x15, 0xd7, 0x12,
	0x49, 0x83, 0xe4, 0xba, 0xf6, 0xd5, 0xab, 0x42, 0x8d, 0xc8, 0x91, 0x84, 0x32, 0xf1, 0x67, 0x81,
	0xe1, 0xae, 0x54, 0xae, 0x97, 0x54, 0xa5, 0xe2, 0x73, 0x0e, 0xf9, 0x06, 0xb9, 0xe7, 0x96, 0x5b,
	0x3e, 0x40, 0x2e, 0x39, 0x25, 0xb9, 0xe5, 0x9a, 0x4b, 0x0e, 0xf9, 0x0e, 0xa9, 0xe9, 0x01, 0x40,
	0x80, 0x22, 0xe5, 0xe4, 0x90, 0x9b, 0xd8, 0xfd, 0x9b, 0x9e, 0xe9, 0xff, 0xdd, 0x10, 0x28, 0xe3,
	0xa9, 0xc5, 0x1c, 0xfe, 0xcc, 0xf3, 0x5d, 0xee, 0x92, 0xe2, 0xd4, 0x75, 0x3d, 0xdf, 0x1b, 0x37,
	0x77, 0xae, 0x5c, 0xf7, 0x6a, 0xca, 0x0e, 0xa8, 0x67, 0x1d, 0x50, 0xc7, 0x71, 0x39, 0xe5, 0x96,
	0xeb, 0x04, 0x12, 0xa6, 0xfd, 0x36, 0x0f, 0xb5, 0x33, 0xd7, 0xf5, 0x7a, 0x33, 0x6e, 0xb0, 0xd7,
	0x33, 0x16, 0x70, 0xa2, 0x42, 0x8e, 0xda, 0xbc, 0x91, 0xd9, 0xcd, 0xec, 0xe5, 0x0c, 0xf1, 0x27,
	0x21, 0x90, 0x9f, 0xb0, 0x80, 0x37, 0xb2, 0xbb, 0x99, 0xbd, 0xb2, 0x81, 0x7f, 0x93, 0x03, 0x78,
	0x68, 0xd3, 0x1b, 0x33, 0x78, 0x4b, 0x3d, 0xd3, 0x77, 0x67, 0xdc, 0x72, 0xae, 0xcc, 0x4b, 0xc6,
	0x1a, 0x39, 0x3c, 0xb6, 0x6e, 0xd3, 0x9b, 0xc1, 0x5b, 0xea, 0x19, 0x92, 0x73, 0xc2, 0x18, 0xf9,
	0x1c, 0x36, 0xc5, 0x01, 0xcf, 0x67, 0x1e, 0xbd, 0x4d, 0x1d, 0xc9, 0xe3, 0x91, 0x0d, 0x9b, 0xde,
	0xf4, 0x91, 0x99, 0x38, 0xb4, 0x0b, 0x4a, 0x7c, 0x8b, 0x80, 0x16, 0x10, 0x0a, 0xa1, 0x74, 0x81,
	0xf8, 0x00, 0x6a, 0x09, 0xb1, 0xe2, 0xe1, 0x6b, 0x88, 0x51, 0x62, 0x71, 0x2d, 0x9b, 0x13, 0x0d,
	0xaa, 0x02, 0x65, 0x5b, 0x0e, 0xf3, 0x51, 0x50, 0x11, 0x41, 0x15, 0x9b, 0xde, 0x9c, 0x0b, 0x9a,
	0x90, 0xf4, 0x09, 0xa8, 0xc2, 0x66, 0xa6, 0x3b, 0xe3, 0xe6, 0xf8, 0x9a, 0x3a, 0x0e, 0x9b, 0x36,
	0x4a, 0xbb, 0x99, 0xbd, 0xfc, 0x51, 0xb6, 0x91, 0x31, 0x6a, 0x53, 0x69, 0xa5, 0xb6, 0xe4, 0x90,
	0x7d, 0x58, 0x77, 0x67, 0xfc, 0xca, 0x15, 0x4a, 0x08, 0xb4, 0x19, 0x30, 0xde, 0xa8, 0xec, 0xe6,
	0xf6, 0xf2, 0x46, 0x3d, 0x62, 0x08, 0xec, 0x80, 0x71, 0x81, 0x0d, 0xde, 0x32, 0xe6, 0x99, 0x63,
	0xd7, 0xb9, 0x34, 0x39, 0xf5, 0xaf, 0x18, 0x6f, 0x94, 0x77, 0x33, 0x7b, 0x05, 0xa3, 0x8e, 0x8c,
	0xb6, 0xeb, 0x5c, 0x0e, 0x91, 0x4c, 0x3e, 0x05, 0x72, 0xcd, 0xa7, 0x63, 0x84, 0x5a, 0xbe, 0x2d,
	0x9d, 0xd5, 0xa8, 0x22, 0x78, 0x5d, 0x70, 0xda, 0x49, 0x06, 0xf9, 0x12, 0xb6, 0xd1, 0x38, 0xde,
	0xec, 0x62, 0x6a, 0x8d, 0x91, 0x68, 0x4e, 0x18, 0x9d, 0x4c, 0x2d, 0x87, 0x35, 0x40, 0xbc, 0xde,
	0xd8, 0x12, 0x80, 0xfe, 0x9c, 0x7f, 0x1c, 0xb2, 0xc9, 0x43, 0x28, 0x4c, 0xe9, 0x05, 0x9b, 0x36,
	0x14, 0xf4, 0xab, 0xfc, 0x41, 0x76, 0xa0, 0x6c, 0x39, 0x16, 0xb7, 0x28, 0x77, 0xfd, 0x46, 0x0d,
	0x39, 0x73, 0x82, 0xf6, 0x63, 0x16, 0xaa, 0x22, 0x5e, 0x3a, 0xce, 0xea, 0x70, 0x59, 0x74, 0x5a,
	0xf6, 0x8e, 0xd3, 0xee, 0xb8, 0x23, 0x77, 0xd7, 0x1d, 0xdb, 0x50, 0x9a, 0xd2, 0x80, 0x9b, 0xd7,
	0xae, 0x87, 0x11, 0xa2, 0x18, 0x45, 0xf1, 0xfb, 0xd4, 0xf5, 0xc8, 0xfb, 0x50, 0x65, 0x37, 0x9c,
	0xf9, 0x0e, 0x9d, 0x9a, 0xc2, 0x24, 0x18, 0x16, 0x25, 0x43, 0x89, 0x88, 0xa7, 0x7c, 0x3a, 0x26,
	0x7b, 0xa0, 0xc6, 0x86, 0x8c, 0x6c, 0xbe, 0x86, 0x66, 0xac, 0x45, 0x66, 0x0c, 0x4d, 0x1e, 0xdb,
	0xa1, 0xb8, 0xd2, 0x0e, 0xa5, 0x45, 0x3b, 0xfc, 0x3d, 0x03, 0x0a, 0x06, 0x38, 0x0b, 0x3c, 0xd7,
	0x09, 0x18, 0x21, 0x90, 0xb5, 0x26, 0x68, 0x85, 0x32, 0xc6, 0x4b, 0xd6, 0x9a, 0x08, 0x15, 0xac,
	0x89, 0x79, 0x71, 0xcb, 0x59, 0x80, 0x1a, 0x2a, 0x46, 0xd1, 0x9a, 0x1c, 0x89, 0x9f, 0xe4, 0x29,
	0x28, 0xf8, 0x3a, 0x3a, 0x99, 0xf8, 0x2c, 0x08, 0x64, 0x6a, 0xe1, 0xc1, 0x8a, 0xa0, 0xb7, 0x24,
	0x99, 0x3c, 0x83, 0x8d, 0x24, 0xcc, 0x74, 0xbc, 0xc3, 0xb7, 0xc1, 0x35, 0xda, 0xa3, 0x2c, 0xc3,
	0x21, 0x44, 0x76, 0x91, 0x41, 0x3e, 0x09, 0xa3, 0x27, 0xc2, 0x4b, 0x78, 0x01, 0xe1, 0x6a, 0x02,
	0xde, 0x47, 0xf4, 0x53, 0xa8, 0x05, 0xcc, 0x7f, 0xc3, 0x7c, 0xd3, 0x66, 0x41, 0x40, 0xaf, 0x18,
	0x1a, 0xa8, 0x6c, 0x54, 0x25, 0xf5, 0x5c, 0x12, 0x35, 0x15, 0x6a, 0xe7, 0xae, 0x63, 0x71, 0xd7,
	0x0f, 0x7d, 0xae, 0xfd, 0x2e, 0x0f, 0x20, 0xb4, 0x1f, 0x70, 0xca, 0x67, 0xc1, 0xd2, 0x8a, 0x21,
	0xac, 0x91, 0x5d, 0x69, 0x8d, 0xca, 0xa2, 0x35, 0xf2, 0xfc, 0xd6, 0x93, 0x61, 0x50, 0x3b, 0x5c,
	0x7f, 0x16, 0xd6, 0xae, 0x67, 0xe2, 0x8e, 0xe1, 0xad, 0xc7, 0x0c, 0x64, 0x93, 0x3d, 0x28, 0x04,
	0x9c, 0x72, 0x59, 0x31, 0x6a, 0x87, 0x24, 0x85, 0x13, 0x6f, 0x61, 0x86, 0x04, 0x90, 0xaf, 0xa1,
	0x76, 0x49, 0xad, 0xe9, 0xcc, 0x67, 0xa6, 0xcf, 0x68, 0xe0, 0x3a, 0x18, 0xc9, 0xb5, 0xc3, 0xcd,
	0xf8, 0xc8, 0x89, 0x64, 0x1b, 0xc8, 0x35, 0xaa, 0x97, 0xc9, 0x9f, 0xe4, 0x43, 0xa8, 0x87, 0xae,
	0x16, 0xf9, 0xc4, 0x2d, 0x3b, 0xaa, 0x3c, 0xb5, 0x39, 0x79, 0x68, 0xd9, 0xe2, 0x45, 0x2a, 0x06,
	0xe9, 0xcc, 0x9b, 0x50, 0xce, 0x24, 0x52, 0xd6, 0x9f, 0x9a, 0xa0, 0x8f, 0x90, 0x8c, 0xc8, 0x45,
	0x87, 0x17, 0x97, 0x3b, 0x7c, 0xb9, 0x03, 0x95, 0x15, 0x0e, 0x5c, 0x11, 0x1e, 0xd5, 0x55, 0xe1,
	0xf1, 0x18, 0x2a, 0x63, 0x37, 0xe0, 0xa6, 0xf4, 0x2f, 0x46, 0x75, 0xce, 0x00, 0x41, 0x1a, 0x20,
	0x85, 0x3c, 0x01, 0x05, 0x01, 0xae, 0x33, 0xbe, 0xa6, 0x96, 0x83, 0x45, 0x2a, 0x67, 0xe0, 0xa1,
	0x9e, 0x24, 0x89, 0xe4, 0x93, 0x90, 0xcb, 0x4b, 0x89, 0x01, 0x59, 0x6f, 0x11, 0x13, 0xd2, 0xe6,
	0x29, 0x55, 0x4f, 0xa4, 0x94, 0x46, 0x40, 0x3d, 0xb3, 0x02, 0x2e, 0xbc, 0x15, 0x44, 0xa1, 0xf4,
	0x3f, 0xb0, 0x9e, 0xa0, 0x85, 0xc9, 0xf4, 0x11, 0x14, 0x44, 0xf5, 0x08, 0x1a, 0x99, 0xdd, 0xdc,
	0x5e, 0xe5, 0x70, 0xe3, 0x8e, 0xa3, 0x67, 0x81, 0x21, 0x11, 0xda, 0x13, 0xa8, 0x0b, 0x62, 0xc7,
	0xb9, 0x74, 0xa3, 0x8a, 0x54, 0x8b, 0x53, 0x51, 0x11, 0x81, 0xa7, 0xd5, 0x40, 0x19, 0x32, 0xdf,
	0x8e, 0xaf, 0xfc, 0x39, 0xd4, 0x3b, 0x4e, 0x48, 0x09, 0x2f, 0xfc, 0x2f, 0xa8, 0xdb, 0x96, 0x23,
	0x4b, 0x16, 0xb5, 0xdd, 0x99, 0xc3, 0x43, 0x87, 0x57, 0x6d, 0xcb, 0x11, 0xf2, 0x5b, 0x48, 0x44,
	0x5c, 0x54, 0xda, 0x42, 0xdc, 0x5a, 0x88, 0x93, 0xd5, 0x4d, 0xe2, 0x5e, 0xe4, 0x4b, 0x19, 0x35,
	0xfb, 0x22, 0x5f, 0xca, 0xaa, 0xb9, 0x17, 0xf9, 0x52, 0x4e, 0xcd, 0xbf, 0xc8, 0x97, 0xf2, 0x6a,
	0xe1, 0x45, 0xbe, 0x54, 0x54, 0x4b, 0xda, 0x1f, 0x33, 0xa0, 0xf6, 0x66, 0xfc, 0x3f, 0xfa, 0x04,
	0x6c, 0x8c, 0x96, 0x63, 0x8e, 0xa7, 0xfc, 0x8d, 0x39, 0x61, 0x53, 0x4e, 0xd1, 0xdd, 0x05, 0x43,
	0xb1, 0x2d, 0xa7, 0x3d, 0xe5, 0x6f, 0x8e, 0x05, 0x2d, 0x6a, 0x9f, 0x09, 0x54, 0x39, 0x44, 0xd1,
	0x9b, 0x18, 0xf5, 0x13, 0xea, 0xfc, 0x26, 0x03, 0xca, 0xb7, 0x33, 0x97, 0xb3, 0xd5, 0x2d, 0x01,
	0x03, 0x6f, 0x5e, 0x87, 0xb3, 0x78, 0x07, 0x8c, 0xe7, 0x35, 0xf8, 0x4e, 0x49, 0xcf, 0x2d, 0x29,
	0xe9, 0xf7, 0x36, 0xbb, 0xfc, 0xbd, 0xcd, 0x4e, 0xfb, 0x55, 0x46, 0x78, 0x3d, 0x7c, 0x66, 0x68,
	0xf2, 0x5d, 0x50, 0xa2, 0x26, 0x65, 0x06, 0x34, 0x7a, 0x30, 0x04, 0xb2, 0x4b, 0x0d, 0x28, 0x4e,
	0x39, 0x98, 0x60, 0x78, 0x63, 0x70, 0x1d, 0x23, 0xc3, 0x29, 0x47, 0xf0, 0xfa, 0x92, 0x15, 0x1e,
	0x78, 0x17, 0x20, 0x61, 0xcb, 0x02, 0xea, 0x59, 0x1e, 0x27, 0x0c, 0x29, 0x4d, 0x98, 0x57, 0x0b,
	0xda, 0x9f, 0x64, 0x14, 0xfc, 0xbb, 0x4f, 0xfa, 0x00, 0x6a, 0xf3, 0x61, 0x07, 0x31, 0xb2, 0xbf,
	0x2a, 0x5e, 0x34, 0xed, 0x08, 0xd4, 0xc7, 0x61, 0x1d, 0x91, 0x73, 0x47, 0xfa, 0xd9, 0x75, 0xc1,
	0x19, 0x08, 0x46, 0x28, 0x12, 0xe7, 0x13, 0x61, 0x57, 0x7a, 0x6b, 0x33, 0x87, 0x9b, 0x38, 0xec,
	0xc9, 0x9e, 0x5b, 0x47, 0x7b, 0x4a, 0xfa, 0xb1, 0xf0, 0xed, 0xfd, 0x0a, 0x6a, 0x75, 0xa8, 0x0e,
	0xdd, 0xef, 0x99, 0x13, 0x27, 0xdb, 0x57, 0x50, 0x8b, 0x08, 0xa1, 0x8a, 0xfb, 0xb0, 0xc6, 0x91,
	0x12, 0x66, 0xf7, 0xbc, 0x8c, 0x9f, 0x05, 0x94, 0x23, 0xd8, 0x08, 0x11, 0xda, 0xef, 0xb3, 0x50,
	0x8e, 0xa9, 0x22, 0x48, 0x2e, 0x68, 0xc0, 0x4c, 0x9b, 0x8e, 0xa9, 0xef, 0xba, 0x4e, 0x98, 0xe3,
	0x8a, 0x20, 0x9e, 0x87, 0x34, 0x51, 0xc2, 0x22, 0x3d, 0xae, 0x69, 0x70, 0x8d, 0xd6, 0x51, 0x8c,
	0x4a, 0x48, 0x3b, 0xa5, 0xc1, 0x35, 0xf9, 0x08, 0xd4, 0x08, 0xe2, 0xf9, 0xcc, 0xb2, 0x45, 0xe7,
	0x93, 0xfd, 0xb9, 0x1e, 0xd2, 0xfb, 0x21, 0x59, 0x14, 0x78, 0x99, 0x64, 0xa6, 0x47, 0xad, 0x89,
	0x69, 0x0b, 0x2b, 0xca, 0x79, 0xb5, 0x26, 0xe9, 0x7d, 0x6a, 0x4d, 0xce, 0x03, 0xca, 0xc9, 0x67,
	0xf0, 0x28, 0x31, 0xd4, 0x26, 0xe0, 0x32, 0x8b, 0x89, 0x1f, 0x4f, 0xb5, 0xf1, 0x91, 0x27, 0xa0,
	0x88, 0x8e, 0x61, 0x8e, 0x7d, 0x46, 0x39, 0x9b, 0x84, 0x79, 0x5c, 0x11, 0xb4, 0xb6, 0x24, 0x91,
	0x06, 0x14, 0xd9, 0x8d, 0x67, 0xf9, 0x6c, 0x82, 0x1d, 0xa3, 0x64, 0x44, 0x3f, 0xc5, 0xe1, 0x80,
	0xbb, 0x3e, 0xbd, 0x62, 0xa6, 0x43, 0x6d, 0x16, 0x8e, 0x28, 0x95, 0x90, 0xd6, 0xa5, 0x36, 0xd3,
	0xde, 0x81, 0xed, 0xe7, 0x8c, 0x9f, 0x59, 0xaf, 0x67, 0xd6, 0xc4, 0xe2, 0xb7, 0x7d, 0xea, 0xd3,
	0x79, 0x15, 0xfc, 0x43, 0x01, 0x36, 0xd2, 0x2c, 0xc6, 0x99, 0x2f, 0x3a, 0x50, 0xc1, 0x9f, 0x4d,
	0x59, 0xe4, 0x9d, 0x79, 0xc7, 0x8c, 0xc1, 0xc6, 0x6c, 0xca, 0x0c, 0x09, 0x22, 0x5f, 0xc3, 0xce,
	0x3c, 0xc4, 0x7c, 0xd1, 0x03, 0x03, 0xca, 0x4d, 0x8f, 0xf9, 0xe6, 0x1b, 0xd1, 0xe9, 0xd1, 0xfa,
	0x98, 0x95, 0x32, 0xda, 0x0c, 0xca, 0x45, 0xc4, 0xf5, 0x99, 0xff, 0x52, 0xb0, 0xc9, 0x87, 0xa0,
	0x26, 0x47, 0x45, 0xd3, 0xf3, 0x6c, 0xf4, 0x44, 0x3e, 0xae, 0x66, 0xc2, 0x5e, 0x9e, 0x4d, 0x3e,
	0x05, 0xb1, 0x1f, 0x98, 0x29, 0x0b, 0x7b, 0x76, 0x98, 0xf4, 0x42, 0xc6, 0x7c, 0x69, 0x10, 0xf0,
	0x2f, 0xa1, 0xb9, 0x7c, 0xd9, 0xc0, 0x53, 0x05, 0x3c, 0xb5, 0xb9, 0x64, 0xe1, 0x10, 0x67, 0xd3,
	0x1b, 0x85, 0xf0, 0xe0, 0x1a, 0xe2, 0xe7, 0x1b, 0x85, 0xc8, 0x99, 0x8f, 0x60, 0x3d, 0x35, 0xc2,
	0x22, 0xb0, 0x88, 0xc0, 0x5a, 0x62, 0x8c, 0x8d, 0xd3, 0x6b, 0x71, 0xfc, 0x2f, 0x2d, 0x1f, 0xff,
	0x9f, 0xc1, 0x46, 0x34, 0xb8, 0x5c, 0xd0, 0xf1, 0xf7, 0xee, 0xe5, 0xa5, 0x19, 0xb0, 0x31, 0x16,
	0xe5, 0xbc, 0xb1, 0x1e, 0xb2, 0x8e, 0x24, 0x67, 0xc0, 0xc6, 0xa4, 0x09, 0x25, 0x3a, 0xe3, 0xae,
	0xf0, 0x11, 0x36, 0xe2, 0x92, 0x11, 0xff, 0x16, 0xb2, 0xa2, 0xbf, 0xcd, 0x8b, 0xd9, 0xe4, 0x8a,
	0xc9, 0x72, 0x51, 0x91, 0xb2, 0x22, 0xd6, 0x11, 0x72, 0xc4, 0x3b, 0xbf, 0x80, 0xed, 0x3b, 0x78,
	0x4e, 0x7d, 0x8e, 0x2f, 0x50, 0xa4, 0xcd, 0x16, 0x4e, 0x09, 0xb6, 0x78, 0xc6, 0xc7, 0x40, 0x04,
	0xc7, 0x14, 0x26, 0xb1, 0x1c, 0xf3, 0x72, 0x6a, 0x5d, 0x5d, 0x73, 0x9c, 0x43, 0xf2, 0x46, 0x5d,
	0x70, 0xce, 0xe9, 0x4d, 0xc7, 0x39, 0x41, 0xf2, 0xb2, 0x4e, 0x57, 0x0b, 0x7d, 0xfe, 0x53, 0x9d,
	0xae, 0x9e, 0x8a, 0x0d, 0x89, 0xd3, 0xfe, 0x92, 0x81, 0x6a, 0x2a, 0x38, 0xb1, 0x48, 0xc9, 0x3d,
	0xcd, 0x0c, 0x27, 0x81, 0xbc, 0x51, 0x0e, 0x29, 0x9d, 0x09, 0xd9, 0x84, 0x35, 0x6f, 0x76, 0xf1,
	0x3d, 0xbb, 0xc5, 0x48, 0x50, 0x8c, 0xf0, 0x17, 0x79, 0x16, 0x8e, 0xa1, 0x59, 0x9c, 0x15, 0x9b,
	0xcb, 0x23, 0x3f, 0x31, 0x8f, 0x7e, 0x0a, 0xc4, 0x72, 0xc6, 0xae, 0x2d, 0x62, 0x8b, 0x5f, 0xfb,
	0x2c, 0xb8, 0x76, 0xa7, 0x13, 0x8c, 0xdf, 0xaa, 0xb1, 0x1e, 0x71, 0x86, 0x11, 0x43, 0xc0, 0xe3,
	0x95, 0x71, 0x0e, 0xcf, 0x4b, 0x78, 0xc4, 0x89, 0xe1, 0xda, 0x2b, 0xd8, 0x1e, 0xac, 0xca, 0x5e,
	0xf2, 0x15, 0x80, 0x17, 0xe7, 0x2c, 0x6a, 0x58, 0x39, 0xdc, 0xb9, 0xfb, 0xe0, 0x79, 0x5e, 0x1b,
	0x09, 0xbc, 0xb6, 0x03, 0xcd, 0x65, 0xa2, 0x65, 0x81, 0xd6, 0x1e, 0xc1, 0xc6, 0x60, 0x76, 0x75,
	0xc5, 0x16, 0x26, 0x35, 0x1f, 0x94, 0x63, 0x2b, 0x78, 0x3d, 0xa3, 0x53, 0xeb, 0xd2, 0x62, 0x93,
	0x7f, 0xdd, 0xc8, 0xb9, 0x94, 0x91, 0x3f, 0x86, 0xb5, 0x70, 0x24, 0x97, 0x66, 0x9e, 0x0f, 0x77,
	0xad, 0x19, 0x77, 0xc3, 0x79, 0x3c, 0x84, 0x68, 0x3f, 0x66, 0xe0, 0x61, 0xfa, 0x2d, 0x61, 0x13,
	0x39, 0x84, 0x52, 0xb4, 0xac, 0x87, 0x85, 0x6a, 0x6b, 0xae, 0x7d, 0xea, 0x7b, 0x86, 0x51, 0x0c,
	0x37, 0x77, 0xf2, 0x05, 0x28, 0x93, 0x84, 0x02, 0x8d, 0x2c, 0x9e, 0x7b, 0x14, 0x9f, 0x4b, 0x6a,
	0x67, 0xa4, 0xa0, 0xfb, 0x4f, 0xa1, 0x14, 0xed, 0x22, 0x44, 0x81, 0xd2, 0x59, 0xaf, 0xd7, 0x37,
	0x7b, 0xa3, 0xa1, 0xfa, 0x80, 0x54, 0xa0, 0x88, 0xbf, 0x3a, 0x5d, 0x35, 0xb3, 0x1f, 0x40, 0x39,
	0x5e, 0x45, 0x48, 0x15, 0xca, 0x9d, 0x6e, 0x67, 0xd8, 0x69, 0x0d, 0xf5, 0x63, 0xf5, 0x01, 0x79,
	0x04, 0xeb, 0x7d, 0x43, 0xef, 0x9c, 0xb7, 0x9e, 0xeb, 0xa6, 0xa1, 0xbf, 0xd4, 0x5b, 0x67, 0xfa,
	0xb1, 0x9a, 0x21, 0x04, 0x6a, 0xa7, 0xc3, 0xb3, 0xb6, 0xd9, 0x1f, 0x1d, 0x9d, 0x75, 0x06, 0xa7,
	0xfa, 0xb1, 0x9a, 0x15, 0x32, 0x07, 0xa3, 0x76, 0x5b, 0x1f, 0x0c, 0xd4, 0x1c, 0x01, 0x58, 0x3b,
	0x69, 0x75, 0x04, 0x38, 0x4f, 0x36, 0xa0, 0xde, 0xe9, 0xbe, 0xec, 0x75, 0xda, 0xba, 0x39, 0xd0,
	0x87, 0x43, 0x41, 0x2c, 0xec, 0xff, 0x23, 0x03, 0xd5, 0xd4, 0x36, 0x43, 0xb6, 0x60, 0x43, 0x1c,
	0x19, 0x19, 0xe2, 0xa6, 0xd6, 0xa0, 0xd7, 0x35, 0xbb, 0xbd, 0xae, 0xae, 0x3e, 0x20, 0xef, 0xc0,
	0xd6, 0x02, 0xa3, 0x77, 0x72, 0xd2, 0x3e, 0x6d, 0x89, 0xc7, 0x93, 0x26, 0x6c, 0x2e, 0x30, 0x87,
	0x9d, 0x73, 0x5d, 0x68, 0x99, 0x25, 0xbb, 0xb0, 0xb3, 0xc0, 0x1b, 0x7c, 0xa7, 0xeb, 0xfd, 0x18,
	0x91, 0x23, 0x4f, 0xe1, 0xc9, 0x02, 0xa2, 0xd3, 0x1d, 0x8c, 0x4e, 0x4e, 0x3a, 0xed, 0x8e, 0xde,
	0x1d, 0x9a, 0x2f, 0x5b, 0x67, 0x23, 0x5d, 0xcd, 0x93, 0x1d, 0x68, 0x2c, 0x5e, 0xa2, 0x9f, 0xf7,
	0x7b, 0x46, 0xcb, 0x78, 0xa5, 0x16, 0xc8, 0xfb, 0xf0, 0xf8, 0x8e, 0x90, 0x76, 0xcf, 0x30, 0xf4,
	0xf6, 0xd0, 0x6c, 0x9d, 0xf7, 0x46, 0xdd, 0xa1, 0xba, 0xb6, 0x7f, 0x20, 0x36, 0x86, 0x85, 0x84,
	0x14, 0x26, 0x1b, 0x75, 0xbf, 0xe9, 0xf6, 0xbe, 0xeb, 0xaa, 0x0f, 0x84, 0xe5, 0x87, 0xa7, 0x86,
	0x3e, 0x38, 0xed, 0x9d, 0x1d, 0xab, 0x99, 0xfd, 0x5f, 0xe6, 0x00, 0xe6, 0xb1, 0x25, 0xac, 0xd3,
	0x1a, 0x0d, 0x7b, 0xd1, 0x0d, 0xf3, 0x63, 0x1a, 0xbc, 0x97, 0x64, 0x1c, 0x8d, 0x8e, 0x9f, 0xeb,
	0x43, 0xb3, 0xdb, 0x1b, 0x9a, 0x83, 0x61, 0xcb, 0x18, 0xa2, 0xbb, 0x9a, 0xb0, 0x99, 0xc4, 0x48,
	0x2b, 0x9c, 0xe8, 0xfa, 0x40, 0xcd, 0x92, 0xf7, 0xa0, 0xb9, 0xe4, 0xbc, 0x7e, 0xd6, 0xea, 0x0f,
	0xf4, 0x63, 0x35, 0x47, 0xb6, 0xe1, 0x51, 0x92, 0xdf, 0xe9, 0x9a, 0x27, 0x67, 0x9d, 0xe7, 0xa7,
	0x43, 0x35, 0x4f, 0x1a, 0xf0, 0x30, 0x2d, 0xb6, 0x85, 0x52, 0xd5, 0xc2, 0xe2, 0xa1, 0xf3, 0x4e,
	0x57, 0x37, 0x90, 0xb5, 0x46, 0x36, 0x81, 0x24, 0x59, 0x7d, 0x43, 0xef, 0xb7, 0x5e, 0xa9, 0x45,
	0xf2, 0x18, 0xde, 0x49, 0xd2, 0x23, 0x8b, 0x1e, 0xb5, 0xda, 0xdf, 0xf4, 0x4e, 0x4e, 0xd4, 0xd2,
	0xe2, 0x6d, 0x71, 0x34, 0x97, 0x17, 0x6d, 0x13, 0x45, 0x36, 0x08, 0xbf, 0xa5, 0x18, 0x9d, 0x6f,
	0x47, 0x9d, 0xe3, 0xce, 0xf0, 0x95, 0xd9, 0xfb, 0x46, 0xad, 0x08, 0xbf, 0x2d, 0xd1, 0x3c, 0x19,
	0x00, 0xaa, 0x72, 0xf8, 0xd7, 0xb2, 0xfc, 0x68, 0xd0, 0xc6, 0xcf, 0x94, 0xc4, 0x80, 0x62, 0x98,
	0xa8, 0x64, 0x55, 0xea, 0x36, 0x1f, 0xa5, 0x16, 0xbf, 0xb8, 0x40, 0x6d, 0xfd, 0xe2, 0xcf, 0x7f,
	0xfb, 0x75, 0x76, 0x5d, 0x53, 0x0e, 0xde, 0x7c, 0x76, 0x20, 0x10, 0x07, 0xee, 0x8c, 0x7f, 0x99,
	0xd9, 0x27, 0x3d, 0x58, 0x93, 0x1f, 0xa7, 0xc8, 0x66, 0x4a, 0x64, 0xfc, 0xb5, 0x6a, 0x95, 0xc4,
	0x4d, 0x94, 0xa8, 0x6a, 0x95, 0x58, 0xa2, 0xe5, 0x08, 0x81, 0x5f, 0x40, 0x31, 0xfc, 0xf4, 0x91,
	0x78, 0x64, 0xfa, 0x63, 0x48, 0x73, 0xd9, 0x76, 0xfa, 0xdf, 0x19, 0xf2, 0xbf, 0x50, 0x8e, 0x17,
	0x5b, 0xb2, 0x9d, 0x28, 0xcd, 0xe9, 0xb2, 0xda, 0x6c, 0x2e, 0x63, 0xa5, 0x9f, 0x45, 0x6a, 0xf1,
	0xb3, 0x70, 0xe9, 0x25, 0x23, 0x59, 0x8e, 0xc4, 0xd2, 0x4b, 0x1a, 0xa9, 0xeb, 0x13, 0x7b, 0xf0,
	0xd2, 0x87, 0x69, 0x4d, 0x14, 0xf9, 0x90, 0x90, 0x94, 0xc8, 0x83, 0x1f, 0xac, 0xc9, 0xff, 0x93,
	0xff, 0x03, 0x25, 0x74, 0x00, 0xae, 0xa6, 0x64, 0x6e, 0xac, 0xe4, 0xfe, 0xdc, 0x9c, 0x2b, 0xb3,
	0xb8, 0xc4, 0x2e, 0x91, 0xee, 0xce, 0xf8, 0x01, 0x47, 0x69, 0x17, 0xb1, 0x74, 0x5c, 0x79, 0x12,
	0xd2, 0x93, 0xcb, 0x63, 0x5a, 0x7a, 0x6a, 0x39, 0xd2, 0x76, 0x51, 0x7a, 0x93, 0x34, 0x52, 0xd2,
	0x5f, 0x0b, 0xcc, 0xc1, 0x0f, 0xd4, 0xe6, 0x42, 0x83, 0x9a, 0x98, 0x78, 0xd1, 0xe5, 0xf7, 0xea,
	0x30, 0xb7, 0xda, 0xc2, 0xa7, 0x00, 0x6d, 0x1b, 0x2f, 0xd9, 0x20, 0xeb, 0x89, 0x50, 0x88, 0x35,
	0x98, 0x4b, 0xbf, 0x57, 0x87, 0xa4, 0xf4, 0xb4, 0x0a, 0x8f, 0x51, 0xfa, 0x36, 0xd9, 0x4a, 0x4a,
	0x4f, 0x6a, 0xf0, 0x0a, 0xaa, 0xe2, 0x8e, 0x68, 0xe7, 0x09, 0x12, 0x91, 0x9c, 0x5a, 0xac, 0x9a,
	0x5b, 0x77, 0xe8, 0xe9, 0xec, 0x20, 0x75, 0xbc, 0x22, 0xa0, 0xfc, 0x40, 0x2e, 0x53, 0x84, 0x03,
	0xb9, 0xbb, 0x0e, 0x10, 0x2d, 0x96, 0xb3, 0x72, 0x57, 0x68, 0xde, 0x3b, 0x59, 0x68, 0x3b, 0x78,
	0xe1, 0x26, 0x79, 0x88, 0x17, 0x46, 0x80, 0x03, 0x4f, 0xca, 0xff, 0x19, 0x90, 0xc1, 0x7d, 0xb7,
	0xae, 0x9c, 0x71, 0x9a, 0xef, 0xdf, 0x8b, 0x49, 0x1b, 0x54, 0x5b, 0x7a, 0xb9, 0x48, 0x61, 0x06,
	0x4a, 0x72, 0x82, 0x20, 0x73, 0x5d, 0x96, 0x0c, 0x39, 0xcd, 0x77, 0x57, 0x70, 0xc3, 0xdb, 0x1a,
	0x78, 0x1b, 0x21, 0xaa, 0xb8, 0x4d, 0xcc, 0xb5, 0x07, 0x81, 0x84, 0x5d, 0xac, 0xe1, 0xff, 0x53,
	0x3e, 0xff, 0x67, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe6, 0x11, 0x1a, 0x17, 0x86, 0x19, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SwapClientClient is the client API for SwapClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SwapClientClient interface {
	// loop: `out`
	//LoopOut initiates an loop out swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream that is
	//returned from Monitor().
	LoopOut(ctx context.Context, in *LoopOutRequest, opts ...grpc.CallOption) (*SwapResponse, error)
	// loop: `in`
	//LoopIn initiates a loop in swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream
	//that is returned from Monitor().
	LoopIn(ctx context.Context, in *LoopInRequest, opts ...grpc.CallOption) (*SwapResponse, error)
	// loop: `monitor`
	//Monitor will return a stream of swap updates for currently active swaps.
	Monitor(ctx context.Context, in *MonitorRequest, opts ...grpc.CallOption) (SwapClient_MonitorClient, error)
	// loop: `listswaps`
	//ListSwaps returns a list of all currently known swaps and their current
	//status.
	ListSwaps(ctx context.Context, in *ListSwapsRequest, opts ...grpc.CallOption) (*ListSwapsResponse, error)
	// loop: `swapinfo`
	//SwapInfo returns all known details about a single swap.
	SwapInfo(ctx context.Context, in *SwapInfoRequest, opts ...grpc.CallOption) (*SwapStatus, error)
	// loop: `terms`
	//LoopOutTerms returns the terms that the server enforces for a loop out swap.
	LoopOutTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*OutTermsResponse, error)
	// loop: `quote`
	//LoopOutQuote returns a quote for a loop out swap with the provided
	//parameters.
	LoopOutQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*OutQuoteResponse, error)
	// loop: `terms`
	//GetTerms returns the terms that the server enforces for swaps.
	GetLoopInTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*InTermsResponse, error)
	// loop: `quote`
	//GetQuote returns a quote for a swap with the provided parameters.
	GetLoopInQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*InQuoteResponse, error)
	// loop: `listauth`
	//GetLsatTokens returns all LSAT tokens the daemon ever paid for.
	GetLsatTokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error)
	//
	//GetLiquidityParams gets the parameters that the daemon's liquidity manager
	//is currently configured with. This may be nil if nothing is configured.
	//[EXPERIMENTAL]: endpoint is subject to change.
	GetLiquidityParams(ctx context.Context, in *GetLiquidityParamsRequest, opts ...grpc.CallOption) (*LiquidityParameters, error)
	//
	//SetLiquidityParams sets a new set of parameters for the daemon's liquidity
	//manager. Note that the full set of parameters must be provided, because
	//this call fully overwrites our existing parameters.
	//[EXPERIMENTAL]: endpoint is subject to change.
	SetLiquidityParams(ctx context.Context, in *SetLiquidityParamsRequest, opts ...grpc.CallOption) (*SetLiquidityParamsResponse, error)
	//
	//SuggestSwaps returns a list of recommended swaps based on the current
	//state of your node's channels and it's liquidity manager parameters.
	//Note that only loop out suggestions are currently supported.
	//[EXPERIMENTAL]: endpoint is subject to change.
	SuggestSwaps(ctx context.Context, in *SuggestSwapsRequest, opts ...grpc.CallOption) (*SuggestSwapsResponse, error)
}

type swapClientClient struct {
	cc *grpc.ClientConn
}

func NewSwapClientClient(cc *grpc.ClientConn) SwapClientClient {
	return &swapClientClient{cc}
}

func (c *swapClientClient) LoopOut(ctx context.Context, in *LoopOutRequest, opts ...grpc.CallOption) (*SwapResponse, error) {
	out := new(SwapResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopIn(ctx context.Context, in *LoopInRequest, opts ...grpc.CallOption) (*SwapResponse, error) {
	out := new(SwapResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) Monitor(ctx context.Context, in *MonitorRequest, opts ...grpc.CallOption) (SwapClient_MonitorClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SwapClient_serviceDesc.Streams[0], "/looprpc.SwapClient/Monitor", opts...)
	if err != nil {
		return nil, err
	}
	x := &swapClientMonitorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SwapClient_MonitorClient interface {
	Recv() (*SwapStatus, error)
	grpc.ClientStream
}

type swapClientMonitorClient struct {
	grpc.ClientStream
}

func (x *swapClientMonitorClient) Recv() (*SwapStatus, error) {
	m := new(SwapStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *swapClientClient) ListSwaps(ctx context.Context, in *ListSwapsRequest, opts ...grpc.CallOption) (*ListSwapsResponse, error) {
	out := new(ListSwapsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/ListSwaps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) SwapInfo(ctx context.Context, in *SwapInfoRequest, opts ...grpc.CallOption) (*SwapStatus, error) {
	out := new(SwapStatus)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/SwapInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopOutTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*OutTermsResponse, error) {
	out := new(OutTermsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopOutTerms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopOutQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*OutQuoteResponse, error) {
	out := new(OutQuoteResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopOutQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLoopInTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*InTermsResponse, error) {
	out := new(InTermsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/GetLoopInTerms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLoopInQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*InQuoteResponse, error) {
	out := new(InQuoteResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/GetLoopInQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLsatTokens(ctx context.Context, in *TokensRequest, opts ...grpc.CallOption) (*TokensResponse, error) {
	out := new(TokensResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/GetLsatTokens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLiquidityParams(ctx context.Context, in *GetLiquidityParamsRequest, opts ...grpc.CallOption) (*LiquidityParameters, error) {
	out := new(LiquidityParameters)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/GetLiquidityParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) SetLiquidityParams(ctx context.Context, in *SetLiquidityParamsRequest, opts ...grpc.CallOption) (*SetLiquidityParamsResponse, error) {
	out := new(SetLiquidityParamsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/SetLiquidityParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) SuggestSwaps(ctx context.Context, in *SuggestSwapsRequest, opts ...grpc.CallOption) (*SuggestSwapsResponse, error) {
	out := new(SuggestSwapsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/SuggestSwaps", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SwapClientServer is the server API for SwapClient service.
type SwapClientServer interface {
	// loop: `out`
	//LoopOut initiates an loop out swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream that is
	//returned from Monitor().
	LoopOut(context.Context, *LoopOutRequest) (*SwapResponse, error)
	// loop: `in`
	//LoopIn initiates a loop in swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream
	//that is returned from Monitor().
	LoopIn(context.Context, *LoopInRequest) (*SwapResponse, error)
	// loop: `monitor`
	//Monitor will return a stream of swap updates for currently active swaps.
	Monitor(*MonitorRequest, SwapClient_MonitorServer) error
	// loop: `listswaps`
	//ListSwaps returns a list of all currently known swaps and their current
	//status.
	ListSwaps(context.Context, *ListSwapsRequest) (*ListSwapsResponse, error)
	// loop: `swapinfo`
	//SwapInfo returns all known details about a single swap.
	SwapInfo(context.Context, *SwapInfoRequest) (*SwapStatus, error)
	// loop: `terms`
	//LoopOutTerms returns the terms that the server enforces for a loop out swap.
	LoopOutTerms(context.Context, *TermsRequest) (*OutTermsResponse, error)
	// loop: `quote`
	//LoopOutQuote returns a quote for a loop out swap with the provided
	//parameters.
	LoopOutQuote(context.Context, *QuoteRequest) (*OutQuoteResponse, error)
	// loop: `terms`
	//GetTerms returns the terms that the server enforces for swaps.
	GetLoopInTerms(context.Context, *TermsRequest) (*InTermsResponse, error)
	// loop: `quote`
	//GetQuote returns a quote for a swap with the provided parameters.
	GetLoopInQuote(context.Context, *QuoteRequest) (*InQuoteResponse, error)
	// loop: `listauth`
	//GetLsatTokens returns all LSAT tokens the daemon ever paid for.
	GetLsatTokens(context.Context, *TokensRequest) (*TokensResponse, error)
	//
	//GetLiquidityParams gets the parameters that the daemon's liquidity manager
	//is currently configured with. This may be nil if nothing is configured.
	//[EXPERIMENTAL]: endpoint is subject to change.
	GetLiquidityParams(context.Context, *GetLiquidityParamsRequest) (*LiquidityParameters, error)
	//
	//SetLiquidityParams sets a new set of parameters for the daemon's liquidity
	//manager. Note that the full set of parameters must be provided, because
	//this call fully overwrites our existing parameters.
	//[EXPERIMENTAL]: endpoint is subject to change.
	SetLiquidityParams(context.Context, *SetLiquidityParamsRequest) (*SetLiquidityParamsResponse, error)
	//
	//SuggestSwaps returns a list of recommended swaps based on the current
	//state of your node's channels and it's liquidity manager parameters.
	//Note that only loop out suggestions are currently supported.
	//[EXPERIMENTAL]: endpoint is subject to change.
	SuggestSwaps(context.Context, *SuggestSwapsRequest) (*SuggestSwapsResponse, error)
}

// UnimplementedSwapClientServer can be embedded to have forward compatible implementations.
type UnimplementedSwapClientServer struct {
}

func (*UnimplementedSwapClientServer) LoopOut(ctx context.Context, req *LoopOutRequest) (*SwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopOut not implemented")
}
func (*UnimplementedSwapClientServer) LoopIn(ctx context.Context, req *LoopInRequest) (*SwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopIn not implemented")
}
func (*UnimplementedSwapClientServer) Monitor(req *MonitorRequest, srv SwapClient_MonitorServer) error {
	return status.Errorf(codes.Unimplemented, "method Monitor not implemented")
}
func (*UnimplementedSwapClientServer) ListSwaps(ctx context.Context, req *ListSwapsRequest) (*ListSwapsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSwaps not implemented")
}
func (*UnimplementedSwapClientServer) SwapInfo(ctx context.Context, req *SwapInfoRequest) (*SwapStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwapInfo not implemented")
}
func (*UnimplementedSwapClientServer) LoopOutTerms(ctx context.Context, req *TermsRequest) (*OutTermsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopOutTerms not implemented")
}
func (*UnimplementedSwapClientServer) LoopOutQuote(ctx context.Context, req *QuoteRequest) (*OutQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoopOutQuote not implemented")
}
func (*UnimplementedSwapClientServer) GetLoopInTerms(ctx context.Context, req *TermsRequest) (*InTermsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLoopInTerms not implemented")
}
func (*UnimplementedSwapClientServer) GetLoopInQuote(ctx context.Context, req *QuoteRequest) (*InQuoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLoopInQuote not implemented")
}
func (*UnimplementedSwapClientServer) GetLsatTokens(ctx context.Context, req *TokensRequest) (*TokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLsatTokens not implemented")
}
func (*UnimplementedSwapClientServer) GetLiquidityParams(ctx context.Context, req *GetLiquidityParamsRequest) (*LiquidityParameters, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLiquidityParams not implemented")
}
func (*UnimplementedSwapClientServer) SetLiquidityParams(ctx context.Context, req *SetLiquidityParamsRequest) (*SetLiquidityParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLiquidityParams not implemented")
}
func (*UnimplementedSwapClientServer) SuggestSwaps(ctx context.Context, req *SuggestSwapsRequest) (*SuggestSwapsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuggestSwaps not implemented")
}

func RegisterSwapClientServer(s *grpc.Server, srv SwapClientServer) {
	s.RegisterService(&_SwapClient_serviceDesc, srv)
}

func _SwapClient_LoopOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoopOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOut(ctx, req.(*LoopOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoopInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopIn(ctx, req.(*LoopInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_Monitor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonitorRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SwapClientServer).Monitor(m, &swapClientMonitorServer{stream})
}

type SwapClient_MonitorServer interface {
	Send(*SwapStatus) error
	grpc.ServerStream
}

type swapClientMonitorServer struct {
	grpc.ServerStream
}

func (x *swapClientMonitorServer) Send(m *SwapStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _SwapClient_ListSwaps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSwapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).ListSwaps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/ListSwaps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).ListSwaps(ctx, req.(*ListSwapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_SwapInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwapInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).SwapInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/SwapInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).SwapInfo(ctx, req.(*SwapInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopOutTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOutTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopOutTerms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOutTerms(ctx, req.(*TermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopOutQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOutQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopOutQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOutQuote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLoopInTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLoopInTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/GetLoopInTerms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLoopInTerms(ctx, req.(*TermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLoopInQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLoopInQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/GetLoopInQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLoopInQuote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLsatTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLsatTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/GetLsatTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLsatTokens(ctx, req.(*TokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLiquidityParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiquidityParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLiquidityParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/GetLiquidityParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLiquidityParams(ctx, req.(*GetLiquidityParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_SetLiquidityParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLiquidityParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).SetLiquidityParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/SetLiquidityParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).SetLiquidityParams(ctx, req.(*SetLiquidityParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_SuggestSwaps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuggestSwapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).SuggestSwaps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/SuggestSwaps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).SuggestSwaps(ctx, req.(*SuggestSwapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SwapClient_serviceDesc = grpc.ServiceDesc{
	ServiceName: "looprpc.SwapClient",
	HandlerType: (*SwapClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoopOut",
			Handler:    _SwapClient_LoopOut_Handler,
		},
		{
			MethodName: "LoopIn",
			Handler:    _SwapClient_LoopIn_Handler,
		},
		{
			MethodName: "ListSwaps",
			Handler:    _SwapClient_ListSwaps_Handler,
		},
		{
			MethodName: "SwapInfo",
			Handler:    _SwapClient_SwapInfo_Handler,
		},
		{
			MethodName: "LoopOutTerms",
			Handler:    _SwapClient_LoopOutTerms_Handler,
		},
		{
			MethodName: "LoopOutQuote",
			Handler:    _SwapClient_LoopOutQuote_Handler,
		},
		{
			MethodName: "GetLoopInTerms",
			Handler:    _SwapClient_GetLoopInTerms_Handler,
		},
		{
			MethodName: "GetLoopInQuote",
			Handler:    _SwapClient_GetLoopInQuote_Handler,
		},
		{
			MethodName: "GetLsatTokens",
			Handler:    _SwapClient_GetLsatTokens_Handler,
		},
		{
			MethodName: "GetLiquidityParams",
			Handler:    _SwapClient_GetLiquidityParams_Handler,
		},
		{
			MethodName: "SetLiquidityParams",
			Handler:    _SwapClient_SetLiquidityParams_Handler,
		},
		{
			MethodName: "SuggestSwaps",
			Handler:    _SwapClient_SuggestSwaps_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Monitor",
			Handler:       _SwapClient_Monitor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client.proto",
}
